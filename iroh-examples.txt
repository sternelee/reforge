This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.github/
  workflows/
    ci.yml
    deploy.yml
browser-chat/
  browser-wasm/
    .cargo/
      config.toml
    src/
      lib.rs
    .gitignore
    Cargo.toml
  cli/
    src/
      main.rs
    .gitignore
    Cargo.toml
  frontend/
    src/
      components/
        ui/
          adaptive-dialog.tsx
          alert-dialog.tsx
          button.tsx
          checkbox.tsx
          dialog.tsx
          drawer.tsx
          input.tsx
          popover.tsx
          scroll-area.tsx
          toggle.tsx
        change-nickname-button.tsx
        chatview.tsx
        header.tsx
        homescreen.tsx
        invitepopup.tsx
        leave-channel-button.tsx
        logview.tsx
        sidebar.tsx
      hooks/
        use-media-query.ts
      lib/
        api.ts
        iroh.ts
        log.ts
        utils.ts
      app.css
      app.tsx
      main.tsx
    .gitignore
    components.json
    index.html
    package.json
    postcss.config.mjs
    tailwind.config.js
    tsconfig.app.json
    tsconfig.json
    tsconfig.node.json
    vite.config.ts
  shared/
    src/
      lib.rs
    .gitignore
    Cargo.toml
  Cargo.toml
  Makefile.toml
  README.md
  tsconfig.json
browser-echo/
  .cargo/
    config.toml
  public/
    index.html
    main.js
    style.css
  src/
    bin/
      cli.rs
    lib.rs
    node.rs
    wasm.rs
  .gitignore
  Cargo.toml
  Makefile.toml
  package.json
  README.md
dumbpipe-web/
  src/
    main.rs
    quinn_endpoint.rs
  Cargo.toml
  LICENSE-APACHE
  LICENSE-MIT
  README.md
extism/
  host/
    src/
      main.rs
    Cargo.toml
  iroh-extism-host-functions/
    src/
      lib.rs
    Cargo.toml
  plugin/
    src/
      lib.rs
    Cargo.toml
  readme.md
framed-messages/
  src/
    framed.rs
    lib.rs
    main.rs
  Cargo.toml
  README.md
frosty/
  src/
    main.rs
  Cargo.toml
  README.md
iroh-automerge/
  src/
    main.rs
    protocol.rs
  .gitignore
  Cargo.toml
  README.md
iroh-gateway/
  self-signed-certs/
    cert.pem
    README.md
  src/
    args.rs
    cert_util.rs
    main.rs
    ranges.rs
  systemd/
    iroh-gateway-https.service
    iroh-gateway.service
    README.md
  .gitignore
  Cargo.toml
  README.md
tauri-todos/
  src/
    component/
      OpenList.tsx
      TodoItem.tsx
      TodoList.tsx
    hooks/
      useDoubleClick.ts
    store/
      todos.ts
    types/
      todo.ts
    App.tsx
    main.tsx
    vite-env.d.ts
  src-tauri/
    capabilities/
      default.json
    src/
      ipc.rs
      iroh.rs
      lib.rs
      main.rs
      state.rs
      todos.rs
    .gitignore
    build.rs
    Cargo.toml
    tauri.conf.json
  .gitignore
  index.html
  LICENSE-APACHE
  LICENSE-MIT
  package.json
  README.md
  tsconfig.json
  tsconfig.node.json
  vite.config.ts
.gitignore
Makefile.toml
README.md

================================================================
Files
================================================================

================
File: .github/workflows/ci.yml
================
name: CI

on:
  pull_request:
  merge_group:

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

env:
  RUST_BACKTRACE: 1
  RUSTFLAGS: -Dwarnings
  RUSTDOCFLAGS: -Dwarnings
  MSRV: "1.81"
  RS_EXAMPLES_LIST: "dumbpipe-web,extism/host,extism/iroh-extism-host-functions,extism/plugin,iroh-automerge,iroh-gateway,frosty,browser-echo,framed-messages"
  WASM_EXAMPLES_LIST: "browser-echo"
  IROH_FORCE_STAGING_RELAYS: "1"

jobs:
  build_and_test_nix:
    timeout-minutes: 30
    name: Build and test (Nix)
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        name: [ubuntu-latest]
        rust: [stable]
        include:
          - name: ubuntu-latest
            os: ubuntu-latest
            release-os: linux
            release-arch: amd64
            runner: [self-hosted, linux, X64]
    env:
      SCCACHE_GHA_ENABLED: "true"
      RUSTC_WRAPPER: "sccache"
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Install ${{ matrix.rust }}
      uses: dtolnay/rust-toolchain@master
      with:
        toolchain: ${{ matrix.rust }}
        components: clippy,rustfmt

    - name: Add wasm target
      run: rustup target add wasm32-unknown-unknown

    - name: Run sccache-cache
      uses: mozilla-actions/sccache-action@v0.0.9

    - name: check
      run: |
        for i in ${RS_EXAMPLES_LIST//,/ }
        do
          echo "Checking $i"
          cargo check --manifest-path $i/Cargo.toml --all-features
        done
      env:
        RUST_LOG: ${{ runner.debug && 'DEBUG' || 'INFO'}}

    - name: wasm
      run: |
        for i in ${WASM_EXAMPLES_LIST//,/ }
        do
          echo "Checking wasm $i"
          cd $i
          # the rust flag should get picked up from the `config.toml` file
          # but cargo build seems to not be picking it up
          # this dependency exists for both `browser-chat` and `browser-echo`
          # so I'm adding the flag to the command
          RUSTFLAGS='--cfg getrandom_backend="wasm_js"' cargo build --target wasm32-unknown-unknown
          cd ..
        done
      env:
        RUST_LOG: ${{ runner.debug && 'DEBUG' || 'INFO'}}

    - name: fmt
      run: |
          for i in ${RS_EXAMPLES_LIST//,/ }
          do
            echo "Checking $i"
            cargo fmt --all --manifest-path $i/Cargo.toml -- --check
          done
      env:
          RUST_LOG: ${{ runner.debug && 'DEBUG' || 'INFO'}}

    - name: clippy
      run: |
          for i in ${RS_EXAMPLES_LIST//,/ }
          do
            echo "Checking $i"
            cargo clippy --manifest-path $i/Cargo.toml
          done
      env:
          RUST_LOG: ${{ runner.debug && 'DEBUG' || 'INFO'}}

================
File: .github/workflows/deploy.yml
================
name: Deploy Preview

on:
  push:
    branches:
      - main
    paths:
      - "browser-echo/**"
      - "browser-chat/**"
  pull_request:
    paths:
      - "browser-echo/**"
      - "browser-chat/**"
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number"
        required: true
        type: string

# ensure job runs sequentially so pushing to the preview branch doesn't conflict
concurrency:
  group: ci-deploy-preview

jobs:
  preview_deploy:
    permissions: write-all
    timeout-minutes: 30
    name: Deploy Docs preview
    if: ${{ github.event_name == 'push' || ((github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch' ) && !github.event.pull_request.head.repo.fork ) }}
    runs-on: ubuntu-latest

    steps:
      - name: Set preview path (PR)
        if: ${{ github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch' }}
        env:
          PREVIEW_PATH: pr/${{ github.event.pull_request.number || inputs.pr_number }}
        run: |
          echo "PREVIEW_PATH=$PREVIEW_PATH" >> "$GITHUB_ENV"

      - name: Set preview path (push)
        if: ${{ github.event_name == 'push' }}
        env:
          PREVIEW_PATH: main
        run: |
          echo "PREVIEW_PATH=$PREVIEW_PATH" >> "$GITHUB_ENV"

      - uses: actions/checkout@v4

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install rust stable toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Add wasm target
        run: rustup target add wasm32-unknown-unknown

      - name: Install tools
        uses: taiki-e/install-action@v2
        with:
          tool: wasm-bindgen,wasm-opt,wasm-pack,cargo-make

      - name: Build examples
        run: cargo make deploy

      - name: Deploy Docs to Preview Branch
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./deploy-out
          destination_dir: ${{ env.PREVIEW_PATH }}
          publish_branch: generated-deploy-preview

      - name: Find Docs Comment
        if: ${{ github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch' }}
        uses: peter-evans/find-comment@v3
        id: fc
        with:
          issue-number: ${{ github.event.pull_request.number || inputs.pr_number }}
          comment-author: "github-actions[bot]"
          body-includes: Deployment for this PR has been generated

      - name: Get current timestamp
        if: ${{ github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch' }}
        id: get_timestamp
        run: echo "TIMESTAMP=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_ENV

      - name: Create or Update Docs Comment
        if: ${{ github.event_name == 'pull_request' || github.event_name == 'workflow_dispatch' }}
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number || inputs.pr_number }}
          comment-id: ${{ steps.fc.outputs.comment-id }}
          body: |
            Deployment for this PR has been generated and is available at: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/${{ env.PREVIEW_PATH }}

            Last updated: ${{ env.TIMESTAMP }}
          edit-mode: replace

================
File: browser-chat/browser-wasm/.cargo/config.toml
================
# we specify the profile here, because it is the only way to define
# different settings for a single crate in a workspace.
[profile.release]
codegen-units = 1
strip = "symbols"
debug = false
lto = true
opt-level = "z"
panic = 'abort'

[target.wasm32-unknown-unknown]
rustflags = ['--cfg', 'getrandom_backend="wasm_js"']

================
File: browser-chat/browser-wasm/src/lib.rs
================
use std::{
    collections::BTreeSet,
    sync::{Arc, Mutex},
};

use anyhow::Result;
use chat_shared::{ChatSender, ChatTicket, NodeId, TopicId};
use n0_future::{time::Duration, StreamExt};
use serde::{Deserialize, Serialize};
use tracing::level_filters::LevelFilter;
use tracing_subscriber_wasm::MakeConsoleWriter;
use wasm_bindgen::{prelude::wasm_bindgen, JsError, JsValue};
use wasm_streams::ReadableStream;

#[wasm_bindgen(start)]
fn start() {
    console_error_panic_hook::set_once();

    tracing_subscriber::fmt()
        .with_max_level(LevelFilter::DEBUG)
        .with_writer(
            // To avoide trace events in the browser from showing their JS backtrace
            MakeConsoleWriter::default().map_trace_level_to(tracing::Level::DEBUG),
        )
        // If we don't do this in the browser, we get a runtime error.
        .without_time()
        .with_ansi(false)
        .init();

    tracing::info!("(testing logging) Logging setup");
}

/// Node for chatting over iroh-gossip
#[wasm_bindgen]
pub struct ChatNode(chat_shared::ChatNode);

#[wasm_bindgen]
impl ChatNode {
    /// Spawns a gossip node.
    pub async fn spawn() -> Result<Self, JsError> {
        let inner = chat_shared::ChatNode::spawn(None)
            .await
            .map_err(to_js_err)?;
        Ok(Self(inner))
    }

    /// Returns the node id of this node.
    pub fn node_id(&self) -> String {
        self.0.node_id().to_string()
    }

    /// Returns information about all the remote nodes this [`Endpoint`] knows about.
    pub fn remote_info(&self) -> Vec<JsValue> {
        self.0
            .remote_info()
            .into_iter()
            .map(|value| serde_wasm_bindgen::to_value(&value).unwrap())
            .collect()
    }

    /// Opens a chat.
    pub async fn create(&self, nickname: String) -> Result<Channel, JsError> {
        // let ticket = ChatTicket::new(topic);
        let ticket = ChatTicket::new_random();
        self.join_inner(ticket, nickname).await
    }

    /// Joins a chat.
    pub async fn join(&self, ticket: String, nickname: String) -> Result<Channel, JsError> {
        let ticket = ChatTicket::deserialize(&ticket).map_err(to_js_err)?;
        self.join_inner(ticket, nickname).await
    }

    async fn join_inner(&self, ticket: ChatTicket, nickname: String) -> Result<Channel, JsError> {
        let (sender, receiver) = self.0.join(&ticket, nickname).await.map_err(to_js_err)?;
        let sender = ChannelSender(sender);
        let neighbors = Arc::new(Mutex::new(BTreeSet::new()));
        let neighbors2 = neighbors.clone();
        let receiver = receiver.map(move |event| {
            if let Ok(event) = &event {
                match event {
                    chat_shared::Event::Joined { neighbors } => {
                        neighbors2.lock().unwrap().extend(neighbors.iter().cloned());
                    }
                    chat_shared::Event::NeighborUp { node_id } => {
                        neighbors2.lock().unwrap().insert(*node_id);
                    }
                    chat_shared::Event::NeighborDown { node_id } => {
                        neighbors2.lock().unwrap().remove(node_id);
                    }
                    _ => {}
                }
            }
            event
                .map_err(|err| JsValue::from(&err.to_string()))
                .map(|event| serde_wasm_bindgen::to_value(&event).unwrap())
        });
        let receiver = ReadableStream::from_stream(receiver).into_raw();

        // Add ourselves to the ticket.
        let mut ticket = ticket;
        ticket.bootstrap.insert(self.0.node_id());
        // ticket.bootstrap = [self.0.node_id()].into_iter().collect();

        let topic = Channel {
            topic_id: ticket.topic_id,
            bootstrap: ticket.bootstrap,
            neighbors,
            me: self.0.node_id(),
            sender,
            receiver,
        };
        Ok(topic)
    }
}

type ChannelReceiver = wasm_streams::readable::sys::ReadableStream;

#[wasm_bindgen]
pub struct Channel {
    topic_id: TopicId,
    me: NodeId,
    bootstrap: BTreeSet<NodeId>,
    neighbors: Arc<Mutex<BTreeSet<NodeId>>>,
    sender: ChannelSender,
    receiver: ChannelReceiver,
}

#[wasm_bindgen]
impl Channel {
    #[wasm_bindgen(getter)]
    pub fn sender(&self) -> ChannelSender {
        self.sender.clone()
    }

    #[wasm_bindgen(getter)]
    pub fn receiver(&mut self) -> ChannelReceiver {
        self.receiver.clone()
    }

    pub fn ticket(&self, opts: JsValue) -> Result<String, JsError> {
        let opts: TicketOpts = serde_wasm_bindgen::from_value(opts)?;
        let mut ticket = ChatTicket::new(self.topic_id);
        if opts.include_myself {
            ticket.bootstrap.insert(self.me);
        }
        if opts.include_bootstrap {
            ticket.bootstrap.extend(self.bootstrap.iter().copied());
        }
        if opts.include_neighbors {
            let neighbors = self.neighbors.lock().unwrap();
            ticket.bootstrap.extend(neighbors.iter().copied())
        }
        tracing::info!("opts {:?} ticket {:?}", opts, ticket);
        Ok(ticket.serialize())
    }

    pub fn id(&self) -> String {
        self.topic_id.to_string()
    }

    pub fn neighbors(&self) -> Vec<String> {
        self.neighbors
            .lock()
            .unwrap()
            .iter()
            .map(|x| x.to_string())
            .collect()
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PeerInfo {
    pub node_id: NodeId,
    pub nickname: String,
    pub last_active: Duration,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TicketOpts {
    pub include_myself: bool,
    pub include_bootstrap: bool,
    pub include_neighbors: bool,
}

#[wasm_bindgen]
#[derive(Debug, Clone)]
pub struct ChannelSender(ChatSender);

#[wasm_bindgen]
impl ChannelSender {
    pub async fn broadcast(&self, text: String) -> Result<(), JsError> {
        self.0.send(text).await.map_err(to_js_err)?;
        Ok(())
    }

    pub fn set_nickame(&self, nickname: String) {
        self.0.set_nickname(nickname);
    }
}

fn to_js_err(err: impl Into<anyhow::Error>) -> JsError {
    let err: anyhow::Error = err.into();
    JsError::new(&err.to_string())
}

================
File: browser-chat/browser-wasm/.gitignore
================
/pkg

================
File: browser-chat/browser-wasm/Cargo.toml
================
[package]
name = "chat-browser"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
anyhow = "1.0.86"
chat-shared = { version = "0.1.0", path = "../shared" }
console_error_panic_hook = "0.1.7"
getrandom = { version = "0.2", features = ["js"] }
n0-future = "0.1.2"
serde = "1.0.217"
serde-wasm-bindgen = "0.6.5"
tracing = "0.1.40"
tracing-subscriber = { version = "0.3.18", features = ["env-filter"] }
tracing-subscriber-wasm = "0.1.0"
wasm-bindgen = "=0.2.100"
wasm-bindgen-futures = "0.4"
wasm-streams = "0.4.2"

[package.metadata.wasm-pack.profile.release]
wasm-opt = ["--enable-nontrapping-float-to-int", "--enable-bulk-memory"]

================
File: browser-chat/cli/src/main.rs
================
use std::collections::HashMap;

use anyhow::{Context, Result};
use chat_shared::{ChatNode, ChatTicket, Event};
use clap::Parser;
use iroh::SecretKey;
use n0_future::StreamExt;
use tokio::io::{AsyncBufReadExt, BufReader};

#[derive(Parser, Debug)]
struct Args {
    #[clap(subcommand)]
    command: Command,
    /// Set your name for this chat session
    #[clap(short, long)]
    nickname: String,
}

#[derive(Parser, Debug)]
pub enum Command {
    /// Create a new chat channel
    Create,
    /// Join a chat channel
    Join {
        /// Ticket for the channel
        ticket: String,
    },
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt::init();
    let args = Args::parse();

    let secret_key = match std::env::var("IROH_SECRET") {
        Err(_) => {
            let secret_key = SecretKey::generate(rand::rngs::OsRng);
            println!("* using new secret. to reuse, set this environment variable:");
            println!(
                "IROH_SECRET={}",
                data_encoding::HEXLOWER.encode(&secret_key.to_bytes())
            );
            secret_key
        }
        Ok(s) => s
            .parse()
            .context("failed to parse secret key from IROH_SECRET environment variable")?,
    };

    let node = ChatNode::spawn(Some(secret_key)).await?;
    println!("node id: {}", node.node_id());

    let ticket = match args.command {
        Command::Create => ChatTicket::new_random(),
        Command::Join { ticket } => ChatTicket::deserialize(&ticket)?,
    };

    let mut our_ticket = ticket.clone();
    our_ticket.bootstrap = [node.node_id()].into_iter().collect();
    println!("* ticket to join this chat:");
    println!("{}", our_ticket.serialize());

    println!("* waiting for peers ...");
    let (sender, mut receiver) = node.join(&ticket, args.nickname).await?;

    let receive = tokio::task::spawn(async move {
        let mut names = HashMap::new();
        while let Some(event) = receiver.try_next().await? {
            match event {
                Event::Joined { neighbors } => {
                    println!("* swarm joined");
                    for node_id in neighbors {
                        println!("* neighbor up: {node_id}")
                    }
                }
                Event::Presence {
                    from,
                    nickname,
                    sent_timestamp: _,
                } => {
                    let from_short = from.fmt_short();
                    if !nickname.is_empty() {
                        let old_name = names.get(&from);
                        if old_name != Some(&nickname) {
                            println!("* {from_short} is now known as {nickname}")
                        }
                    }
                    names.insert(from, nickname.clone());
                }
                Event::MessageReceived {
                    from,
                    text,
                    nickname,
                    sent_timestamp: _,
                } => {
                    let from_short = from.fmt_short();
                    if !nickname.is_empty() {
                        let old_name = names.get(&from);
                        if old_name != Some(&nickname) {
                            println!("* {from_short} is now known as {nickname}")
                        }
                    }
                    println!("<{from_short}> {nickname}: {text}");
                }
                Event::NeighborUp { node_id } => {
                    println!("* neighbor up: {node_id}")
                }
                Event::NeighborDown { node_id } => {
                    println!("* neighbor down: {node_id}")
                }
                Event::Lagged => {
                    println!("* warn: gossip stream lagged")
                }
            }
        }
        println!("* closed");
        anyhow::Ok(())
    });

    let send = tokio::task::spawn(async move {
        let mut input = BufReader::new(tokio::io::stdin()).lines();
        while let Some(line) = input.next_line().await? {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }
            println!("* sending message: {line}");
            sender.send(line.to_string()).await?;
        }
        anyhow::Ok(())
    });

    // TODO: Clean shutown.
    receive.await??;
    send.await??;
    Ok(())
}

================
File: browser-chat/cli/.gitignore
================
/target

================
File: browser-chat/cli/Cargo.toml
================
[package]
name = "chat-cli"
version = "0.1.0"
edition = "2024"

[dependencies]
anyhow = "1.0.95"
clap = { version = "4.5.29", features = ["derive"] }
iroh = { workspace = true, default-features = false }
n0-future = "0.1.2"
rand = "0.8"
chat-shared = { version = "0.1.0", path = "../shared" }
tokio = { version = "1.43.0", features = ["rt", "macros"] }
tracing-subscriber = "0.3.19"
data-encoding = "2.9"

================
File: browser-chat/frontend/src/components/ui/adaptive-dialog.tsx
================
"use client"

import * as React from "react"
import { useIsDesktop } from "@/hooks/use-media-query"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import {
  Drawer,
  DrawerClose,
  DrawerContent,
  DrawerDescription,
  DrawerFooter,
  DrawerHeader,
  DrawerTitle,
  DrawerTrigger,
} from "@/components/ui/drawer"

const AdaptiveDialogContext = React.createContext<{
  isDesktop: boolean
}>({ isDesktop: true })

export function AdaptiveDialog({ children, ...props }: React.ComponentProps<typeof Dialog>) {
  const isDesktop = useIsDesktop()

  if (isDesktop) {
    return (
      <AdaptiveDialogContext.Provider value={{ isDesktop }}>
        <Dialog modal={true} {...props}>{children}</Dialog>
      </AdaptiveDialogContext.Provider>
    )
  }

  return (
    <AdaptiveDialogContext.Provider value={{ isDesktop }}>
      <Drawer {...props}>{children}</Drawer>
    </AdaptiveDialogContext.Provider>
  )
}

export function AdaptiveDialogTrigger({ children }: { children: React.ReactNode }) {
  const { isDesktop } = React.useContext(AdaptiveDialogContext)

  if (isDesktop) {
    return <DialogTrigger asChild>{children}</DialogTrigger>
  }

  return <DrawerTrigger asChild>{children}</DrawerTrigger>
}

export function AdaptiveDialogContent({ children, ...props }: React.ComponentProps<typeof DialogContent>) {
  const { isDesktop } = React.useContext(AdaptiveDialogContext)

  if (isDesktop) {
    return <DialogContent {...props}>{children}</DialogContent>
  }

  return (
    <DrawerContent {...props}>
      {children}
      <DrawerFooter className="pt-2">
        <DrawerClose asChild>
          <button className="btn btn-outline">Cancel</button>
        </DrawerClose>
      </DrawerFooter>
    </DrawerContent>
  )
}

export function AdaptiveDialogHeader({ children, ...props }: React.ComponentProps<typeof DialogHeader>) {
  const { isDesktop } = React.useContext(AdaptiveDialogContext)

  if (isDesktop) {
    return <DialogHeader {...props}>{children}</DialogHeader>
  }

  return <DrawerHeader {...props}>{children}</DrawerHeader>
}

export function AdaptiveDialogTitle({ children, ...props }: React.ComponentProps<typeof DialogTitle>) {
  const { isDesktop } = React.useContext(AdaptiveDialogContext)

  if (isDesktop) {
    return <DialogTitle {...props}>{children}</DialogTitle>
  }

  return <DrawerTitle {...props}>{children}</DrawerTitle>
}

export function AdaptiveDialogDescription({ children, ...props }: React.ComponentProps<typeof DialogDescription>) {
  const { isDesktop } = React.useContext(AdaptiveDialogContext)

  if (isDesktop) {
    return <DialogDescription {...props}>{children}</DialogDescription>
  }

  return <DrawerDescription {...props}>{children}</DrawerDescription>
}

================
File: browser-chat/frontend/src/components/ui/alert-dialog.tsx
================
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

================
File: browser-chat/frontend/src/components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: browser-chat/frontend/src/components/ui/checkbox.tsx
================
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

================
File: browser-chat/frontend/src/components/ui/dialog.tsx
================
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

================
File: browser-chat/frontend/src/components/ui/drawer.tsx
================
import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}

================
File: browser-chat/frontend/src/components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

================
File: browser-chat/frontend/src/components/ui/popover.tsx
================
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }

================
File: browser-chat/frontend/src/components/ui/scroll-area.tsx
================
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

================
File: browser-chat/frontend/src/components/ui/toggle.tsx
================
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }

================
File: browser-chat/frontend/src/components/change-nickname-button.tsx
================
import { FormEvent, useEffect, useState } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import {
  AdaptiveDialog,
  AdaptiveDialogContent,
  AdaptiveDialogHeader,
  AdaptiveDialogTitle,
  AdaptiveDialogTrigger,
} from "@/components/ui/adaptive-dialog"
import { API } from "@/lib/api"

interface ChangeNicknameProps {
  api: API
  channel: string
}

export function ChangeNicknameButton({ api, channel }: ChangeNicknameProps) {
  const [myself, setMyself] = useState(api.getMyself(channel))
  const [name, setName] = useState(myself.name)
  const [open, setOpen] = useState(false)
  useEffect(() => {
    return api.subscribeToPeers(channel, () => {
      setMyself(api.getMyself(channel))
    })
  }, [api, channel])
  const handleSubmit = (e: FormEvent) => {
    e.preventDefault()
    if (name.trim()) {
      api.setNickname(channel, name)
      setOpen(false)
    }
  }
  return (
    <AdaptiveDialog open={open} onOpenChange={setOpen}>
      <AdaptiveDialogTrigger>
        <Button variant="secondary" size="sm">Change nickname</Button>
      </AdaptiveDialogTrigger>
      <AdaptiveDialogContent className="sm:max-w-[425px]">
        <AdaptiveDialogHeader>
          <AdaptiveDialogTitle>Change nickname</AdaptiveDialogTitle>
        </AdaptiveDialogHeader>
        <form onSubmit={handleSubmit} className="flex space-x-2">
          <Input value={name} onChange={(e) => setName(e.target.value)} placeholder="Enter your nickname" />
          <Button size="sm" type="submit">Save</Button>
        </form>
      </AdaptiveDialogContent>
    </AdaptiveDialog>
  )
}

================
File: browser-chat/frontend/src/components/chatview.tsx
================
"use client"

import type React from "react"

import { useState, useRef, useEffect, useCallback } from "react"
import TimeAgo from 'react-timeago'
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover"
import { ArrowDown, ChevronLeft, Settings } from "lucide-react"
import { type API, Message, PeerInfo, PeerRole } from "../lib/api"
import { log } from "../lib/log"
import clsx from "clsx"
import { LeaveChannelButton } from "./leave-channel-button"
import { ChangeNicknameButton } from "./change-nickname-button"

import { useIsDesktop } from "@/hooks/use-media-query"
import { Toggle } from "./ui/toggle"
import { InviteButton } from "./invitepopup"

interface ChatViewProps extends MessageViewProps {
  api: API
  channel: string
  onClose: () => void
}

export default function ChatView({ api, channel, onClose }: ChatViewProps) {
  const isDesktop = useIsDesktop()
  const [showMeta, setShowMeta] = useState(false)
  const cls = clsx(
    "flex flex-grow overflow-hidden",
  )
  let extraButtons
  if (!isDesktop) {
    extraButtons = (
      <Toggle pressed={showMeta} onPressedChange={setShowMeta} title="peers and settings">
        {!showMeta && <Settings />}
        {showMeta && <ChevronLeft />}
      </Toggle>
    )
  }
  return (
    <div className={cls}>
      {(isDesktop || !showMeta) && (
        <MessageView api={api} channel={channel} extraButtons={extraButtons} />
      )}
      {(isDesktop) && (
        <div className="w-md">
          <Meta api={api} channel={channel} onClose={onClose} />
        </div>
      )}
      {(showMeta) && <Meta api={api} channel={channel} onClose={onClose} extraButtons={extraButtons} />}
    </div>
  )
}

interface MessageViewProps {
  api: API
  channel: string
  extraButtons?: React.ReactElement
}

export function MessageView({ api, channel, extraButtons }: MessageViewProps) {
  const [messages, setMessages] = useState<Message[]>([])
  const [inputMessage, setInputMessage] = useState("")
  const [showScrollButton, setShowScrollButton] = useState(false)
  const [isScrolledToBottom, setIsScrolledToBottom] = useState(true)
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const scrollAreaRef = useRef<HTMLDivElement>(null)


  const scrollToBottom = useCallback(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: "smooth" })
    }
    setShowScrollButton(false)
    setIsScrolledToBottom(true)
  }, [])


  useEffect(() => {
    setMessages(api.getMessages(channel))
    scrollToBottom()

    // Subscribe to new messages
    const unsubscribeMessages = api.subscribeToMessages(channel, (newMessage) => {
      setMessages((prevMessages) => {
        // Check if the message already exists to prevent duplicates
        if (!prevMessages.some((msg) => msg.id === newMessage.id)) {
          const updatedMessages = [...prevMessages, newMessage]
          if (isScrolledToBottom) {
            setTimeout(scrollToBottom, 0)
          } else {
            setShowScrollButton(true)
          }
          return updatedMessages
        }
        return prevMessages
      })
      log.info(`New message received: ${newMessage.content}`)
    })


    // Cleanup function
    return unsubscribeMessages
  }, [channel, isScrolledToBottom, scrollToBottom])

  const handleSendMessage = async (e: React.FormEvent) => {
    e.preventDefault()
    if (inputMessage.trim()) {
      try {
        await api.sendMessage(channel, inputMessage.trim())
        setInputMessage("")
        log.info(`Message sent in channel ${channel}: ${inputMessage.trim()}`)
      } catch (error) {
        log.error('Failed to send message', error)
      }
    }
  }

  const handleScroll = useCallback(() => {
    if (scrollAreaRef.current) {
      const { scrollTop, scrollHeight, clientHeight } = scrollAreaRef.current
      const isBottom = scrollTop + clientHeight >= scrollHeight - 10
      setIsScrolledToBottom(isBottom)
      setShowScrollButton(!isBottom)
    }
  }, [])

  useEffect(() => {
    if (isScrolledToBottom) {
      scrollToBottom()
    }
  }, [isScrolledToBottom, scrollToBottom])

  useEffect(() => {
    const scrollArea = scrollAreaRef.current
    if (scrollArea) {
      scrollArea.addEventListener("scroll", handleScroll)
      return () => scrollArea.removeEventListener("scroll", handleScroll)
    }
  }, [handleScroll])

  return (
    <div className="flex-grow flex flex-col p-4 relative">
      <ScrollArea className="flex-grow mb-4 border rounded-md p-4" ref={scrollAreaRef} onScroll={handleScroll}>
        {messages.map((msg) => (
          <div key={msg.id} className="mb-2">
            <span className="font-bold">{msg.nickname || msg.sender.substring(0, 8)}: </span>
            {msg.content}
          </div>
        ))}
        <div ref={messagesEndRef} />
      </ScrollArea>
      {showScrollButton && (
        <Button className="absolute bottom-20 right-4 rounded-full p-2" onClick={scrollToBottom} size="icon">
          <ArrowDown className="h-4 w-4" />
        </Button>
      )}
      <form onSubmit={handleSendMessage} className="flex space-x-2">
        <Input
          value={inputMessage}
          onChange={(e) => setInputMessage(e.target.value)}
          placeholder="Type your message..."
          className="flex-grow"
        />
        <Button type="submit">
          Send
        </Button>
        {extraButtons}
      </form>
    </div>
  )
}

function Meta({ api, channel, onClose, extraButtons }: ChatViewProps & { extraButtons?: React.ReactElement }) {
  const [peers, setPeers] = useState<PeerInfo[]>([])
  const [neighbors, setNeighbors] = useState(0)
  useEffect(() => {
    return api.subscribeToNeighbors(channel, setNeighbors)
  }, [channel])

  useEffect(() => {
    setPeers([...api.getPeers(channel)])
    return api.subscribeToPeers(channel, () => setPeers([...api.getPeers(channel)]))
  }, [channel])
  const sortedPeers = [...peers].sort((a, b) => {
    const statusOrder = { online: 0, away: 1, offline: 2 }
    return statusOrder[a.status] - statusOrder[b.status]
  })

  return (
    <div className="p-4 border-l flex flex-col">
      <div>
        {extraButtons}
      </div>
      <div className="mb-4">
        <h2 className="font-bold mb-2">Status</h2>
        {neighbors > 0 && (
          <p>Connected <span className="text-sm">({neighbors} neighbors)</span></p>
        )}
        {neighbors === 0 && (
          <p>Waiting for peers</p>
        )}
      </div>
      <div className="mb-4 flex space-x-2">
        <InviteButton channel={channel} getTicket={opts => api.getTicket(channel, opts)} />
      </div>
      <div className="mb-4 flex space-x-2">
        <ChangeNicknameButton api={api} channel={channel} />
        <LeaveChannelButton onConfirm={onClose} />
      </div>
      <h2 className="font-bold mb-2">Peers</h2>
      <div className="flex-grow">
        <ScrollArea className="h-full">
          {sortedPeers.map((peer) => (
            <Peer peer={peer} key={peer.id} />
          ))}
        </ScrollArea>
      </div>
    </div>
  )
}



interface PeerProps {
  peer: PeerInfo
}

function Peer({ peer }: PeerProps) {
  const isMyself = peer.role == PeerRole.Myself
  const popoverContent = isMyself ? <MyselfInfo peer={peer} /> :
    <RemotePeerInfo peer={peer} />
  return (
    <Popover>
      <PopoverTrigger asChild>
        <div className="flex items-center mb-2 cursor-pointer">
          <div className={`w-2 h-2 rounded-full mr-2 ${getStatusColor(peer.status)}`}></div>
          <span className={clsx(isMyself && 'italic')}>{peer.name}</span>
        </div>
      </PopoverTrigger>
      <PopoverContent className="w-80 bg-secondary">
        {popoverContent}
      </PopoverContent>
    </Popover>
  )
}

function MyselfInfo({ peer }: PeerProps) {
  return (
    <div className="space-y-2">
      This is us :)
      <div>
        <strong>Node ID:</strong>
        <NodeId nodeId={peer.id} />
      </div>
    </div>
  )
}

function RemotePeerInfo({ peer }: PeerProps) {
  return (
    <div className="space-y-2">
      <p>
        <strong>Last seen:</strong> <TimeAgo date={peer.lastSeen} />
      </p>
      <div>
        <strong>Node ID:</strong>
        <NodeId nodeId={peer.id} />
      </div>
    </div>
  )
}

interface NodeIdProps {
  nodeId: string
}

function NodeId({ nodeId }: NodeIdProps) {
  return (
    <>
      <span className="ml-2 font-mono">{nodeId.substring(0, 8)}</span>
      <Button size="sm" onClick={() => copyToClipboard(nodeId)} className="ml-2 inline" variant="outline">
        Copy
      </Button>
    </>
  )
}

function copyToClipboard(text: string) {
  navigator.clipboard.writeText(text)
}

function getStatusColor(status: PeerInfo["status"]) {
  switch (status) {
    case "online":
      return "bg-green-500"
    case "away":
      return "bg-yellow-500"
    case "offline":
      return "bg-red-500"
    default:
      return "bg-gray-500"
  }
}

================
File: browser-chat/frontend/src/components/header.tsx
================
"use client"

import { Button } from "@/components/ui/button"
import { UserPlus, Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"
import { useEffect, useState } from "react"
import { LogViewButton } from "./logview"

interface HeaderProps {
  onInviteClick?: () => void
  title?: string | null
}

export default function Header({
  onInviteClick,
  title,
}: HeaderProps) {
  return (
    <header className="bg-background text-foreground p-4 flex justify-between items-center">
      <div className="flex items-center">
        {title && <h1 className="text-xl font-bold mr-4">{title}</h1>}
      </div>
      <div className="flex items-center space-x-2">
        {onInviteClick && (
          <Button onClick={onInviteClick} variant="default">
            <UserPlus className="w-4 h-4 mr-2" />
            Invite
          </Button>
        )}
        <LogViewButton />
        {/* <Button onClick={onLogsClick} variant="secondary">
          <FileText className="w-4 h-4 mr-2" />
          Logs
        </Button> */}
        <ThemeToggle />
      </div>
    </header>
  )
}

function ThemeToggle() {
  const { theme, setTheme } = useTheme()
  const [mounted, setMounted] = useState(false)

  useEffect(() => setMounted(true), [])

  if (!mounted) return null

  return (
    <Button variant="ghost" size="icon" onClick={() => setTheme(theme === "light" ? "dark" : "light")}>
      {theme === "light" ? <Moon className="h-5 w-5" /> : <Sun className="h-5 w-5" />}
      <span className="sr-only">Toggle theme</span>
    </Button>
  )
}

================
File: browser-chat/frontend/src/components/homescreen.tsx
================
"use client"

import { useState, type FormEvent } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"

import { generate as generateName } from 'yet-another-name-generator'

interface HomeScreenProps {
  onJoin: (ticket: string, nickname: string) => void
  onCreate: (nickname: string) => void
}

export default function HomeScreen({ onJoin, onCreate }: HomeScreenProps) {
  const [ticket, setTicket] = useState(() => {
    const url = new URL(document.location.toString())
    const ticket = url.searchParams.get("ticket")
    if (ticket?.startsWith("chat")) return ticket
    return ""
  })

  const [nickname, setNickname] = useState(generateName())

  const handleJoin = (e: FormEvent) => {
    e.preventDefault()
    if (ticket.trim()) {
      onJoin(ticket.trim(), nickname)
    }
  }

  const handleCreate = (e: FormEvent) => {
    e.preventDefault()
    onCreate(nickname)
  }

  return (
    <div className="flex flex-col items-center justify-center flex-grow p-4">
      <div className="w-full max-w-md space-y-4">
        <div>
          <h2 className="text-lg font-semibold mb-2">Your name</h2>
          <div className="flex space-x-2">
            <Input value={nickname} onChange={(e) => setNickname(e.target.value)} placeholder="Enter your name" />
          </div>
        </div>
        <form onSubmit={handleJoin}>
          <h2 className="text-lg font-semibold mb-2">Join Channel</h2>
          <div className="flex space-x-2">
            <Input value={ticket} onChange={(e) => setTicket(e.target.value)} placeholder="Enter ticket" />
            <Button type="submit" disabled={!nickname.length || !ticket.length}>Join</Button>
          </div>
        </form>
        <form onSubmit={handleCreate}>
          <h2 className="text-lg font-semibold mb-2">Create Channel</h2>
          <div className="flex space-x-2">
            <Button type="submit" disabled={!nickname.length}>Create</Button>
          </div>
        </form>
      </div>
    </div>
  )
}

================
File: browser-chat/frontend/src/components/invitepopup.tsx
================
"use client"

import { useState, useRef, useMemo } from "react"
import { Button } from "@/components/ui/button"
import { Checkbox } from "@/components/ui/checkbox"
import { Input } from "@/components/ui/input"
import {
  AdaptiveDialog,
  AdaptiveDialogContent,
  AdaptiveDialogHeader,
  AdaptiveDialogTitle,
  AdaptiveDialogTrigger,
} from "@/components/ui/adaptive-dialog"
import { Copy, Share2 } from "lucide-react"
import { TicketOpts } from "@/lib/api"
import { useIsDesktop } from "@/hooks/use-media-query"
import clsx from "clsx"

function ticketUrl(ticket: string) {
  const baseUrl = new URL(document.location.toString())
  baseUrl.searchParams.set("ticket", ticket)
  return baseUrl.toString()
}

interface InvitePopupProps {
  channel: string
  getTicket: (options: {
    includeMyself: boolean
    includeBootstrap: boolean
    includeNeighbors: boolean
  }) => string
}
export function InviteButton({ channel, getTicket }: InvitePopupProps) {
  const [open, setOpen] = useState(false)
  const isDesktop = useIsDesktop()
  const cls = clsx(
    isDesktop ? 'w-2xl max-w-3xl' : 'max-w-[100vw]',
    "max-h-[80vh]"
  )
  return (
    <AdaptiveDialog open={open} onOpenChange={setOpen}>
      <AdaptiveDialogTrigger>
        <Button variant="default">
          <Share2 />
          Invite peers
        </Button>
      </AdaptiveDialogTrigger>
      <AdaptiveDialogContent className={cls}>
        <div className="">
          <AdaptiveDialogHeader>
            <AdaptiveDialogTitle>Invite peers</AdaptiveDialogTitle>
          </AdaptiveDialogHeader>
          <div className="grow-0 mt-2 max-h-[60vh] max-w-2xl overflow-auto">
            <InvitePopupContent channel={channel} getTicket={getTicket} />
          </div>
        </div>
      </AdaptiveDialogContent>
    </AdaptiveDialog>
  )
}


export function InvitePopupContent({ channel, getTicket }: InvitePopupProps) {
  const [ticketOptions, setTicketOptions] = useState<TicketOpts>({
    includeMyself: true,
    includeBootstrap: true,
    includeNeighbors: false,
  })
  const ticket = useMemo(() => getTicket(ticketOptions), [ticketOptions, channel])
  const cliCommandRef = useRef<HTMLInputElement>(null)


  function copyToClipboard(text: string) {
    navigator.clipboard.writeText(text)
  }

  const cliCommand = `cargo run -- join ${ticket}`

  const ticketUrlFull = ticketUrl(ticket)
  const ticketUrlShort = ticketUrl(ticket.substring(0, 16))

  return (
    <>
      <div className="mb-4">
        <p className="font-semibold mb-2">Ticket</p>
        <div className="flex items-center">
          <span className="mr-2 font-mono">{ticket.substring(0, 16)}...</span>
          <Button variant="outline" size="sm" onClick={() => copyToClipboard(ticket)}>
            <Copy className="w-4 h-4 mr-2" />
            Copy
          </Button>
        </div>
      </div>
      <div className="mb-4">
        <p className="font-semibold mb-2">Join link</p>
        <div className="flex items-center space-x-2">
          <a href={ticketUrlFull} className="text-blue-500 hover:underline" target="_blank">
            {ticketUrlShort}
          </a>
          <Button variant="outline" size="sm" onClick={() => copyToClipboard(ticketUrlFull)}>
            <Copy className="w-4 h-4 mr-2" />
            Copy
          </Button>
        </div>
      </div>
      <div className="mb-4">
        <p className="font-semibold mb-2">Join from the command line</p>
        <Input
          ref={cliCommandRef}
          value={cliCommand}
          readOnly
          className="mb-2"
          onClick={() => cliCommandRef.current?.select()}
        />
        <Button variant="outline" size="sm" onClick={() => copyToClipboard(cliCommand)}>
          <Copy className="w-4 h-4 mr-2" />
          Copy to Clipboard
        </Button>
      </div>
      <div className="mb-4">
        <h3 className="font-semibold mb-2">Configure ticket</h3>
        <div className="space-y-2">
          <div className="flex items-center">
            <Checkbox
              id="include-myself"
              checked={ticketOptions.includeMyself}
              onCheckedChange={(checked) => setTicketOptions({ ...ticketOptions, includeMyself: !!checked })}
            />
            <label htmlFor="include-myself" className="ml-2">
              Include myself
            </label>
          </div>
          <div className="flex items-center">
            <Checkbox
              id="include-bootstrap"
              checked={ticketOptions.includeBootstrap}
              onCheckedChange={(checked) => setTicketOptions({ ...ticketOptions, includeBootstrap: !!checked })}
            />
            <label htmlFor="include-bootstrap" className="ml-2">
              Include my bootstrap
            </label>
          </div>
          <div className="flex items-center">
            <Checkbox
              id="include-neighbors"
              checked={ticketOptions.includeNeighbors}
              onCheckedChange={(checked) => setTicketOptions({ ...ticketOptions, includeNeighbors: !!checked })}
            />
            <label htmlFor="include-neighbors" className="ml-2">
              Include my current neighbors
            </label>
          </div>
        </div>
      </div >
    </>
  )
}

================
File: browser-chat/frontend/src/components/leave-channel-button.tsx
================
import {
  AdaptiveDialog,
  AdaptiveDialogContent,
  AdaptiveDialogDescription,
  AdaptiveDialogHeader,
  AdaptiveDialogTitle,
  AdaptiveDialogTrigger,
} from "@/components/ui/adaptive-dialog"
import { Button } from "@/components/ui/button"

interface LeaveChannelProps {
  onConfirm: () => void
}
export function LeaveChannelButton({ onConfirm }: LeaveChannelProps) {
  return (
    <AdaptiveDialog>
      <AdaptiveDialogTrigger>
        <Button size="sm" variant="destructive">Leave channel</Button>
      </AdaptiveDialogTrigger>
      <AdaptiveDialogContent>
        <AdaptiveDialogHeader>
          <AdaptiveDialogTitle>
            Are you sure?
          </AdaptiveDialogTitle>
          <AdaptiveDialogDescription>
            If you want to rejoin the channel, make sure to save a ticket first by clicking the <em>Invite</em> button.
          </AdaptiveDialogDescription>
        </AdaptiveDialogHeader>
        <Button onClick={onConfirm}>Leave channel</Button>
      </AdaptiveDialogContent>
    </AdaptiveDialog>
  )
}

================
File: browser-chat/frontend/src/components/logview.tsx
================
import { ScrollArea } from "@/components/ui/scroll-area"
import { Button } from "@/components/ui/button"
import {
  AdaptiveDialog,
  AdaptiveDialogContent,
  AdaptiveDialogHeader,
  AdaptiveDialogTitle,
  AdaptiveDialogTrigger,
} from "@/components/ui/adaptive-dialog"
import { useEffect, useState } from "react";
import { log, LogMessage } from "@/lib/log";
import { FileText } from "lucide-react";
import { useIsDesktop } from "@/hooks/use-media-query";
import clsx from "clsx";

export function LogViewButton() {
  const [open, setOpen] = useState(false)
  const isDesktop = useIsDesktop()
  const cls = clsx(
    isDesktop ? 'w-2xl max-w-3xl' : 'max-w-[100vw]',
    "max-h-[80vh]"
  )
  return (
    <AdaptiveDialog open={open} onOpenChange={setOpen}>
      <AdaptiveDialogTrigger>
        <Button variant="secondary">
          <FileText className="w-4 h-4 mr-2" />
          Logs
        </Button>
      </AdaptiveDialogTrigger>
      <AdaptiveDialogContent className={cls}>
        <div className="">
          <AdaptiveDialogHeader>
            <AdaptiveDialogTitle>Logs</AdaptiveDialogTitle>
          </AdaptiveDialogHeader>
          <div className="grow-0 mt-2 max-h-[60vh] max-w-2xl overflow-auto">
            <LogView />
          </div>
        </div>
      </AdaptiveDialogContent>
    </AdaptiveDialog>
  )
}

export function LogView() {
  const logs = useLogs();

  const formatTimestamp = (date: Date) => {
    return date.toTimeString().split(" ")[0] + "." + date.getMilliseconds().toString().padStart(3, "0").slice(0, 2)
  }

  const getLogColor = (level: "info" | "warn" | "error") => {
    switch (level) {
      case "error":
        return "text-red-500"
      case "warn":
        return "text-yellow-500"
      default:
        return "text-foreground"
    }
  }

  return (
    <div className="max-w-3xl overflow-hidden flex flex-col relative">
      <ScrollArea className="flex-grow mb-4 font-mono overflow-auto">
        <div className="space-y-1">
          {logs.map((log, index) => (
            <div key={index} className={`${getLogColor(log.level)}`}>
              <span className="text-muted-foreground">{formatTimestamp(log.timestamp)}</span> {log.message}
            </div>
          ))}
        </div>
      </ScrollArea>
    </div>
  )
}


function useLogs() {
  const [logs, setLogs] = useState<LogMessage[]>([...log.get()])
  useEffect(() => {
    const unsubscribe = log.subscribe((logMessage) => {
      setLogs((prevLogs) => [...prevLogs, logMessage])
    })
    return () => unsubscribe()
  }, [])
  return logs
}

================
File: browser-chat/frontend/src/components/sidebar.tsx
================
"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { ScrollArea } from "@/components/ui/scroll-area"
import { PlusCircle, Hash, ChevronLeft, ChevronRight } from "lucide-react"
import type { ChannelInfo } from "../lib/api"
import clsx from "clsx"

interface SidebarProps {
  channels: ChannelInfo[]
  activeChannel: string | null
  onChannelSelect: (channelId: string) => void
  onNewChannel: () => void
}

export default function Sidebar({ channels, activeChannel, onChannelSelect, onNewChannel }: SidebarProps) {
  const [isCollapsed, setIsCollapsed] = useState(false)

  return (
    <div className={`bg-secondary h-full flex flex-col transition-all duration-300 ${isCollapsed ? "w-12" : "w-64"}`}>
      <div className="p-4 flex justify-between items-center">
        {!isCollapsed && <h2 className="text-lg font-semibold">Channels</h2>}
        <Button variant="ghost" size="icon" onClick={() => setIsCollapsed(!isCollapsed)}>
          {isCollapsed ? <ChevronRight className="h-5 w-5" /> : <ChevronLeft className="h-5 w-5" />}
        </Button>
      </div>
      <ScrollArea className="flex-grow">
        {channels.map((channel) => {
          const cls = clsx(
            channel.id === activeChannel && "bg-primary/10",
            isCollapsed ? "px-2" : "px-4"
          )
          return (
            <Button
              key={channel.id}
              variant="ghost"
              className={`w-full justify-start px-4 py-2 hover:bg-primary/20 rounded-none ${cls}`}
              onClick={() => onChannelSelect(channel.id)}
            >
              <Hash className="h-4 w-4 mr-2" />
              {!isCollapsed && channel.name}
            </Button>
          )
        })}
      </ScrollArea>
      <Button variant="default" onClick={onNewChannel} className="m-4">
        <PlusCircle className="h-5 w-5" />
        Add channel
      </Button>
    </div>
  )
}

================
File: browser-chat/frontend/src/hooks/use-media-query.ts
================
import * as React from "react"

export function useMediaQuery(query: string) {
  const [value, setValue] = React.useState(false)

  React.useEffect(() => {
    function onChange(event: MediaQueryListEvent) {
      setValue(event.matches)
    }

    const result = matchMedia(query)
    result.addEventListener("change", onChange)
    setValue(result.matches)

    return () => result.removeEventListener("change", onChange)
  }, [query])

  return value
}

export function useIsDesktop() {
  const isDesktop = useMediaQuery("(min-width: 768px)")
  return isDesktop
}

================
File: browser-chat/frontend/src/lib/api.ts
================
import { log } from './log'

// We want to only ever create the API once, therefore we define a module-level
// singleton that holds the promise to create the API.
// As promises can be awaited any number of times in JavaScript, this gives us
// an async singleton instance to the wasm API.
const api = importAndInitOnce()

export async function initApi() {
  return await api
}

async function importAndInitOnce() {
  try {
    log.info("Importing WASM module")
    const { IrohAPI } = await import('./iroh')
    return await IrohAPI.create()
  } catch (err) {
    log.error('Failed to import or launch iroh', err)
    throw err
  }
}

export interface API {
  createChannel(nickname: string): Promise<ChannelInfo>
  joinChannel(ticket: string, nickname: string): Promise<ChannelInfo>
  sendMessage(channelId: string, message: string): void
  setNickname(channelId: string, nickname: string): void
  getMessages(channelId: string): Message[]
  getPeers(channelId: string): PeerInfo[]
  getMyself(channelId: string): PeerInfo
  subscribeToMessages(
    channelId: string,
    callback: (message: Message) => void,
  ): () => void
  subscribeToPeers(
    channelId: string,
    callback: () => void,
  ): () => void
  subscribeToNeighbors(
    channelId: string,
    callback: (neighbors: number) => void,
  ): () => void
  getTicket(channelId: string, opts: TicketOpts): string
  closeChannel(channelId: string): Promise<void>
}

export type SubscribeCb = (message: Message) => void;

export type ChannelInfo = {
  id: string
  name: string
}

export type TicketOpts = {
  includeMyself: boolean
  includeBootstrap: boolean
  includeNeighbors: boolean
}

export interface Message {
  id: string; sender: string; content: string, nickname?: string
}

export interface PeerInfo {
  id: string
  name: string
  status: "online" | "away" | "offline"
  lastSeen: Date
  role: PeerRole
}

export enum PeerRole {
  Myself,
  RemoteNode
}

================
File: browser-chat/frontend/src/lib/iroh.ts
================
import { PeerRole, type API, type ChannelInfo, type Message, type PeerInfo, type SubscribeCb, type TicketOpts } from "./api"
import { log } from "./log"
import { ChatNode, Channel as IrohChannel } from "chat-browser"

type ChannelState = {
  label: string
  myself: PeerInfo
  messages: Message[]
  peers: Map<string, PeerInfo>
  channel: IrohChannel
  subscribers: SubscribeCb[]
  neighborSubscribers: ((neighbors: number) => void)[]
  peerSubscribers: (() => void)[]
  neighbors: number
  nextId: number
  onClose: (() => void)
}

export class IrohAPI implements API {
  private chatNode: ChatNode
  private channels: Map<string, ChannelState> = new Map()

  private constructor(chatNode: ChatNode) {
    this.chatNode = chatNode
  }

  static async create(): Promise<IrohAPI> {
    log.info("Spawning iroh node")
    const chatNode = await ChatNode.spawn()
    log.info(`Iroh node spawned. our node id: ${chatNode.node_id()}`)
    return new IrohAPI(chatNode)
  }

  async createChannel(nickname: string): Promise<ChannelInfo> {
    const channel = await this.chatNode.create(nickname)
    return this.joinInner(channel, nickname)
  }

  async joinChannel(ticket: string, nickname: string): Promise<ChannelInfo> {
    const channel = await this.chatNode.join(ticket, nickname)
    return this.joinInner(channel, nickname)
  }

  joinInner(channel: IrohChannel, nickname: string) {
    const id = channel.id()
    log.info(`joining channel ${id}`)
    const label = id.substring(5, 13)
    let onClose
    let onClosePromise = new Promise<void>(resolve => {
      onClose = resolve
    })
    const nodeId = this.chatNode.node_id()
    const myself: PeerInfo = {
      id: nodeId,
      name: nickname,
      lastSeen: new Date(),
      status: "online",
      role: PeerRole.Myself
    }
    const state: ChannelState = {
      label,
      messages: [],
      channel,
      subscribers: [],
      peers: new Map(),
      nextId: 0,
      neighbors: 0,
      neighborSubscribers: [],
      peerSubscribers: [],
      myself,
      onClose: onClose!
    }
    state.peers.set(nodeId, myself)
    this.channels.set(id, state)

    const subscribe = async () => {
      const reader = channel.receiver.getReader() as ReadableStreamDefaultReader<ChatEvent>
      while (true) {
        const { done, value } = await reader.read()
        if (done) {
          break;
        }
        const event = value;
        console.debug("channel event", id.substring(0, 8), event)
        if (event.type === "messageReceived") {
          const peerInfo: PeerInfo = {
            id: event.from,
            name: event.nickname,
            lastSeen: new Date(event.sentTimestamp / 1000),
            status: "online",
            role: PeerRole.RemoteNode
          }
          state.peers.set(event.from, peerInfo)
          const message: Message = {
            id: nextId(state),
            sender: event.from,
            content: event.text,
          }
          state.messages.push(message)
          const messageWithName = withName(state, message)
          for (const sub of state.subscribers) {
            sub(messageWithName)
          }
          for (const sub of state.peerSubscribers) { sub() }
        } else if (event.type === "presence") {
          const peerInfo: PeerInfo = {
            id: event.from,
            name: event.nickname,
            lastSeen: new Date(event.sentTimestamp / 1000),
            status: "online",
            role: PeerRole.RemoteNode
          }
          state.peers.set(event.from, peerInfo)
          for (const sub of state.peerSubscribers) { sub() }
        } else if (event.type === "joined") {
          log.info(`joined channel ${id}`)
          state.neighbors += event.neighbors.length
          for (const sub of state.neighborSubscribers) { sub(state.neighbors) }
        } else if (event.type === "neighborUp") {
          state.neighbors += 1
          for (const sub of state.neighborSubscribers) { sub(state.neighbors) }
        } else if (event.type === "neighborDown") {
          state.neighbors -= 1
          for (const sub of state.neighborSubscribers) { sub(state.neighbors) }
        }
      }
    }

    const checkPeers = async () => {
      while (true) {
        const now = new Date()
        for (const peer of state.peers.values()) {
          if (peer.id === nodeId) {
            peer.lastSeen = now
            continue
          }
          const diff = (now.getTime() - peer.lastSeen.getTime()) / 1000;
          if (diff > 20) {
            peer.status = "offline"
          } else if (diff > 10) {
            peer.status = "away"
          } else {
            peer.status = "online"
          }
        }
        await new Promise(resolve => setTimeout(resolve, 1000))
      }
    }

    Promise.race([
      onClosePromise,
      subscribe(),
      checkPeers()
    ])

    return { id, name: label }
  }

  getMyself(channelId: string): PeerInfo {
    const state = this.channels.get(channelId)
    if (!state) {
      throw new Error("Channel not found")
    }
    return { ...state.myself }
  }

  getTicket(channelId: string, opts: TicketOpts) {
    const state = this.channels.get(channelId)
    if (!state) {
      throw new Error("Channel not found")
    }
    return state.channel.ticket(opts)
  }

  async closeChannel(channelId: string): Promise<void> {
    const state = this.channels.get(channelId)
    if (!state) {
      throw new Error("Channel not found")
    }
    state.onClose()
    this.channels.delete(channelId)
  }


  async sendMessage(channelId: string, text: string): Promise<void> {
    const state = this.channels.get(channelId)
    if (!state) {
      throw new Error("Channel not found")
    }
    await state.channel.sender.broadcast(text)
    const me = this.chatNode.node_id();
    const message = {
      sender: me,
      id: nextId(state),
      content: text
    }
    state.messages.push(message)
    const messageWithName = withName(state, message)
    for (const sub of state.subscribers) {
      sub(messageWithName)
    }
  }

  setNickname(channelId: string, nickname: string) {
    const state = this.channels.get(channelId)
    if (!state) {
      throw new Error("Channel not found")
    }
    console.log('state', state)
    log.info(`changing nickname from ${state.myself.name} to ${nickname}`)
    state.myself.name = nickname
    state.channel.sender.set_nickame(nickname)
    for (const sub of state.peerSubscribers) { sub() }
  }


  getMessages(channelId: string): Message[] {
    const state = this.channels.get(channelId)
    if (!state) {
      throw new Error("Channel not found")
    }
    const messages = state.messages.map(message => withName(state, message))
    return messages
  }

  getPeers(
    channelId: string,
  ): PeerInfo[] {
    const state = this.channels.get(channelId)
    if (!state) {
      throw new Error("Channel not found")
    }
    return Array.from(state.peers.values())
  }

  subscribeToMessages(
    channelId: string,
    callback: (message: Message) => void,
  ): () => void {
    const state = this.channels.get(channelId)
    if (!state) {
      throw new Error("Channel not found")
    }
    state.subscribers.push(callback)
    return () => {
      state.subscribers = state.subscribers.filter(cb => cb != callback)
    }
  }

  subscribeToNeighbors(channelId: string, callback: (neighbors: number) => void): () => void {
    const state = this.channels.get(channelId)
    if (!state) {
      throw new Error("Channel not found")
    }
    callback(state.neighbors)
    state.neighborSubscribers.push(callback)
    return () => {
      state.neighborSubscribers = state.neighborSubscribers.filter(cb => cb != callback)
    }
  }

  subscribeToPeers(
    channelId: string,
    callback: () => void,
  ): () => void {
    const state = this.channels.get(channelId)
    if (!state) {
      throw new Error("Channel not found")
    }
    state.peerSubscribers.push(callback)
    return () => {
      state.peerSubscribers = state.peerSubscribers.filter(cb => cb != callback)
    }
  }
}

function getName(state: ChannelState, from: string) {
  const peer = state.peers.get(from)
  if (peer && peer.name) return peer.name
  return from.substring(0, 8)
}

function withName(state: ChannelState, message: Message): Message {
  return { ...message, nickname: getName(state, message.sender) }
}

function nextId(state: ChannelState): string {
  const id = "" + state.nextId
  state.nextId = state.nextId + 1
  return id
}

// types used in chat-browser, for now they are defined manually here.
type JoinedEvent = {
  type: "joined"
  neighbors: string[]
}

type MessageEvent = {
  type: "messageReceived"
  from: string,
  text: string,
  nickname: string,
  sentTimestamp: number,
}

type PresenceEvent = {
  type: "presence"
  from: string,
  nickname: string,
  sentTimestamp: number,
}

type NeighborUpEvent = {
  type: "neighborUp"
  nodeId: string
}

type NeighborDownEvent = {
  type: "neighborDown"
  nodeId: string
}

type LaggedEvent = {
  type: "lagged"
}

type ChatEvent = JoinedEvent | MessageEvent | NeighborUpEvent | NeighborDownEvent | PresenceEvent | LaggedEvent

================
File: browser-chat/frontend/src/lib/log.ts
================
// Log system
export type LogLevel = "info" | "warn" | "error"

export type LogMessage = {
  timestamp: Date
  level: LogLevel
  message: string
}

class LogSystem {
  private logs: LogMessage[] = []
  private subscribers: Set<(log: LogMessage) => void> = new Set()

  error(message: any, error?: any) {
    console.error(message, error)
    this.log(`${message} ${error || ""}`, "error")
  }

  info(message: string) {
    this.log(message)
  }

  log(message: string, level: LogLevel = "info") {
    const logMessage: LogMessage = {
      timestamp: new Date(),
      level,
      message,
    }
    this.logs.push(logMessage)
    this.notifySubscribers(logMessage)

  }

  get(): LogMessage[] {
    return this.logs
  }

  subscribe(callback: (log: LogMessage) => void): () => void {
    this.subscribers.add(callback)
    return () => {
      this.subscribers.delete(callback)
    }
  }

  private notifySubscribers(log: LogMessage) {
    this.subscribers.forEach((callback) => callback(log))
  }
}

export const log = new LogSystem()

================
File: browser-chat/frontend/src/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: browser-chat/frontend/src/app.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

html {
    background: hsl(0 0% 3.9%);
}

body {
    font-family: Arial, Helvetica, sans-serif;
    display: none;
}

@layer utilities {
    .text-balance {
        text-wrap: balance;
    }
}

@layer base {
    :root {
        --background: 0 0% 100%;
        --foreground: 0 0% 3.9%;
        --card: 0 0% 100%;
        --card-foreground: 0 0% 3.9%;
        --popover: 0 0% 100%;
        --popover-foreground: 0 0% 3.9%;
        --primary: 0 0% 9%;
        --primary-foreground: 0 0% 98%;
        --secondary: 0 0% 96.1%;
        --secondary-foreground: 0 0% 9%;
        --muted: 0 0% 96.1%;
        --muted-foreground: 0 0% 45.1%;
        --accent: 0 0% 96.1%;
        --accent-foreground: 0 0% 9%;
        --destructive: 0 84.2% 60.2%;
        --destructive-foreground: 0 0% 98%;
        --border: 0 0% 89.8%;
        --input: 0 0% 89.8%;
        --ring: 0 0% 3.9%;
        --chart-1: 12 76% 61%;
        --chart-2: 173 58% 39%;
        --chart-3: 197 37% 24%;
        --chart-4: 43 74% 66%;
        --chart-5: 27 87% 67%;
        --radius: 0.5rem;
        --sidebar-background: 0 0% 98%;
        --sidebar-foreground: 240 5.3% 26.1%;
        --sidebar-primary: 240 5.9% 10%;
        --sidebar-primary-foreground: 0 0% 98%;
        --sidebar-accent: 240 4.8% 95.9%;
        --sidebar-accent-foreground: 240 5.9% 10%;
        --sidebar-border: 220 13% 91%;
        --sidebar-ring: 217.2 91.2% 59.8%;
    }
    .dark {
        --background: 0 0% 3.9%;
        --foreground: 0 0% 98%;
        --card: 0 0% 3.9%;
        --card-foreground: 0 0% 98%;
        --popover: 0 0% 3.9%;
        --popover-foreground: 0 0% 98%;
        --primary: 0 0% 98%;
        --primary-foreground: 0 0% 9%;
        --secondary: 0 0% 14.9%;
        --secondary-foreground: 0 0% 98%;
        --muted: 0 0% 14.9%;
        --muted-foreground: 0 0% 63.9%;
        --accent: 0 0% 14.9%;
        --accent-foreground: 0 0% 98%;
        --destructive: 0 62.8% 30.6%;
        --destructive-foreground: 0 0% 98%;
        --border: 0 0% 14.9%;
        --input: 0 0% 14.9%;
        --ring: 0 0% 83.1%;
        --chart-1: 220 70% 50%;
        --chart-2: 160 60% 45%;
        --chart-3: 30 80% 55%;
        --chart-4: 280 65% 60%;
        --chart-5: 340 75% 55%;
        --sidebar-background: 240 5.9% 10%;
        --sidebar-foreground: 240 4.8% 95.9%;
        --sidebar-primary: 224.3 76.3% 48%;
        --sidebar-primary-foreground: 0 0% 100%;
        --sidebar-accent: 240 3.7% 15.9%;
        --sidebar-accent-foreground: 240 4.8% 95.9%;
        --sidebar-border: 240 3.7% 15.9%;
        --sidebar-ring: 217.2 91.2% 59.8%;
    }
}

@layer base {
    * {
        @apply border-border;
    }
    body {
        @apply bg-background text-foreground;
    }
    .dark body,
    .light body {
        @apply block;
    }
}

================
File: browser-chat/frontend/src/app.tsx
================
"use client"

import { useState, useEffect } from "react"
import HomeScreen from "./components/homescreen"
import ChatView from "./components/chatview"
import Header from "./components/header"
import Sidebar from "./components/sidebar"
import { ThemeProvider } from "next-themes"
import { API, initApi, type ChannelInfo } from "./lib/api"
import { log } from "./lib/log"
import { useIsDesktop } from "./hooks/use-media-query"

export default function AppWrapper() {
  const [api, setApi] = useState<API | null>(null)
  const [error, setError] = useState<string | null>(null)
  useEffect(() => {
    initApi()
      .then(setApi)
      .catch(err => setError(err.toString()))
  }, [])
  return (
    <ThemeProvider attribute="class" defaultTheme="system" enableSystem>
      <div className="flex h-screen">
        {!api && (
          <SplashScreen>
            {!error && <div className="text-center">Spawning Iroh<br /><Spinner /></div>}
            {error && <div>{error}</div>}
          </SplashScreen>
        )}
        {api && <App api={api} />}
      </div>
    </ThemeProvider>
  )
}

function Spinner() {
  return (
    <svg className="inline-block h-5 w-5 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
    </svg>
  )
}

function SplashScreen({ children }: React.PropsWithChildren) {
  return (
    <div className="flex flex-col flex-grow">
      <Header />
      <div className="flex items-center justify-center">
        {children}
      </div>
    </div>
  )

}

interface AppProps {
  api: API
}

function App({ api }: AppProps) {
  const [currentView, setCurrentView] = useState<"home" | "chat">("home")
  const [channels, setChannels] = useState<ChannelInfo[]>([])
  const [activeChannel, setActiveChannel] = useState<string | null>(null)
  const [showSidebar, setShowSidebar] = useState(false)

  const joinChannel = async (ticket: string, nickname: string) => {
    try {
      const channel = await api.joinChannel(ticket, nickname)
      setChannels((prevChannels) => [...prevChannels, channel])
      setCurrentView("chat")
      setActiveChannel(channel.id)
      setShowSidebar(true)
    } catch (error) {
      log.error("Failed to join channel", error)
    }
  }

  const createChannel = async (nickname: string) => {
    try {
      const channel = await api.createChannel(nickname)
      setChannels((prevChannels) => [...prevChannels, channel])
      setActiveChannel(channel.id)
      setCurrentView("chat")
      setShowSidebar(true)
    } catch (error) {
      log.error("Failed to create channel", error)
    }
  }

  const closeChannel = async (channelId: string) => {
    try {
      await api.closeChannel(channelId)
      setChannels((prevChannels) => prevChannels.filter((channel) => channel.id !== channelId))
      if (activeChannel === channelId) {
        setActiveChannel(channels.length > 1 ? channels[0].id : null)
        if (channels.length === 1) {
          setCurrentView("home")
        }
      }
    } catch (error) {
      log.error("Failed to close channel", error)
    }
  }

  const handleNewChannel = () => {
    setCurrentView("home")
    setShowSidebar(true)
  }

  const isDesktop = useIsDesktop()

  let title
  if (activeChannel) {
    title = '#' + channels.find((c) => c.id === activeChannel)?.name
  }

  return (
    <>
      {isDesktop && (showSidebar) && (
        <Sidebar
          channels={channels}
          activeChannel={activeChannel}
          onChannelSelect={(channelId) => {
            setActiveChannel(channelId)
            setCurrentView("chat")
          }}
          onNewChannel={handleNewChannel}
        />
      )}
      <div className="flex flex-col flex-grow">
        <Header
          title={title}
        />
        {currentView === "home" && (
          <HomeScreen
            onJoin={joinChannel}
            onCreate={createChannel}
          />
        )}
        {currentView === "chat" && activeChannel && (
          <ChatView api={api} channel={activeChannel} onClose={() => closeChannel(activeChannel)} />
        )}
      </div>
    </>
  )
}

================
File: browser-chat/frontend/src/main.tsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './app.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================
File: browser-chat/frontend/.gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules

# next.js
/.next/
/out/

# production
/build
/dist

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: browser-chat/frontend/components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: browser-chat/frontend/index.html
================
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Iroh Chat</title>
        <link href="/src/app.css" rel="stylesheet" />
    </head>
    <body>
        <div id="root"></div>
        <script type="module" src="/src/main.tsx"></script>
    </body>
</html>

================
File: browser-chat/frontend/package.json
================
{
  "name": "iroh-chat-frontend",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build --base='./'",
    "lint": "eslint .",
    "preview": "vite preview",
    "build:wasm": "wasm-pack build ../browser-wasm --dev --weak-refs --reference-types -t bundler -d pkg",
    "build:wasm:release": "wasm-pack build ../browser-wasm --release -t bundler -d pkg"
  },
  "dependencies": {
    "@radix-ui/react-alert-dialog": "^1.1.6",
    "@radix-ui/react-checkbox": "^1.1.4",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-scroll-area": "^1.2.3",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-toggle": "^1.1.2",
    "@types/react-timeago": "^4.1.7",
    "autoprefixer": "^10.4.20",
    "chat-browser": "file:../browser-wasm/pkg",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.454.0",
    "next-themes": "latest",
    "react": "^18",
    "react-dom": "^18",
    "react-timeago": "^7.2.0",
    "tailwind-merge": "^2.5.5",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^1.1.2",
    "yet-another-name-generator": "^1.2.0"
  },
  "devDependencies": {
    "@tailwindcss/vite": "^4.0.7",
    "@types/node": "^22",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@vitejs/plugin-react": "^4.3.4",
    "postcss": "^8",
    "tailwindcss": "^3.4.17",
    "typescript": "^5",
    "vite": "^6.1.1",
    "vite-plugin-top-level-await": "^1.5.0",
    "vite-plugin-wasm": "^3.4.1"
  }
}

================
File: browser-chat/frontend/postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: browser-chat/frontend/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: ["./index.html", "./src/**/*.{ts,tsx}", "*.{js,ts,jsx,tsx,mdx}"],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
};

================
File: browser-chat/frontend/tsconfig.app.json
================
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: browser-chat/frontend/tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ],
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}

================
File: browser-chat/frontend/tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: browser-chat/frontend/vite.config.ts
================
import path from "path"
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import wasm from "vite-plugin-wasm";
import topLevelAwait from "vite-plugin-top-level-await";

// https://vite.dev/config/
export default defineConfig({
  plugins: [
    react(),
    wasm(),
    topLevelAwait(),
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
})

================
File: browser-chat/shared/src/lib.rs
================
use std::{
    collections::BTreeSet,
    sync::{Arc, Mutex},
};

use anyhow::{Context, Result};
pub use iroh::NodeId;
use iroh::{endpoint::RemoteInfo, protocol::Router, PublicKey, SecretKey};
use iroh_base::{ticket::Ticket, Signature};
pub use iroh_gossip::proto::TopicId;
use iroh_gossip::{
    api::{Event as GossipEvent, GossipSender},
    net::{Gossip, GOSSIP_ALPN},
};
use n0_future::{
    boxed::BoxStream,
    task::{self, AbortOnDropHandle},
    time::{Duration, SystemTime},
    StreamExt,
};
use serde::{Deserialize, Serialize};
use tokio::sync::{Mutex as TokioMutex, Notify};
use tracing::{debug, info, warn};

pub const TOPIC_PREFIX: &str = "iroh-example-chat/0:";
pub const PRESENCE_INTERVAL: Duration = Duration::from_secs(5);

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct ChatTicket {
    pub topic_id: TopicId,
    pub bootstrap: BTreeSet<NodeId>,
}

impl ChatTicket {
    pub fn new_random() -> Self {
        let topic_id = TopicId::from_bytes(rand::random());
        Self::new(topic_id)
    }

    pub fn new(topic_id: TopicId) -> Self {
        Self {
            topic_id,
            bootstrap: Default::default(),
        }
    }
    pub fn deserialize(input: &str) -> Result<Self> {
        <Self as Ticket>::deserialize(input).map_err(Into::into)
    }
    pub fn serialize(&self) -> String {
        <Self as Ticket>::serialize(self)
    }
}

impl Ticket for ChatTicket {
    const KIND: &'static str = "chat";

    fn to_bytes(&self) -> Vec<u8> {
        postcard::to_stdvec(&self).unwrap()
    }

    fn from_bytes(bytes: &[u8]) -> Result<Self, iroh_base::ticket::ParseError> {
        let ticket = postcard::from_bytes(bytes)?;
        Ok(ticket)
    }
}

pub struct ChatNode {
    secret_key: SecretKey,
    router: Router,
    gossip: Gossip,
}

impl ChatNode {
    /// Spawns a gossip node.
    pub async fn spawn(secret_key: Option<SecretKey>) -> Result<Self> {
        let secret_key = secret_key.unwrap_or_else(|| SecretKey::generate(rand::rngs::OsRng));
        let endpoint = iroh::Endpoint::builder()
            .secret_key(secret_key.clone())
            .discovery_n0()
            .alpns(vec![GOSSIP_ALPN.to_vec()])
            .bind()
            .await?;

        let node_id = endpoint.node_id();
        info!("endpoint bound");
        info!("node id: {node_id:#?}");

        let gossip = Gossip::builder().spawn(endpoint.clone());
        info!("gossip spawned");
        let router = Router::builder(endpoint)
            .accept(GOSSIP_ALPN, gossip.clone())
            .spawn();
        info!("router spawned");
        Ok(Self {
            gossip,
            router,
            secret_key,
        })
    }

    /// Returns the node id of this node.
    pub fn node_id(&self) -> NodeId {
        self.router.endpoint().node_id()
    }

    /// Returns information about all the remote nodes this [`Endpoint`] knows about.
    pub fn remote_info(&self) -> Vec<RemoteInfo> {
        self.router
            .endpoint()
            .remote_info_iter()
            .collect::<Vec<_>>()
    }

    /// Joins a chat channel from a ticket.
    ///
    /// Returns a [`ChatSender`] to send messages or change our nickname
    /// and a stream of [`Event`] items for incoming messages and other event.s
    pub async fn join(
        &self,
        ticket: &ChatTicket,
        nickname: String,
    ) -> Result<(ChatSender, BoxStream<Result<Event>>)> {
        let topic_id = ticket.topic_id;
        let bootstrap = ticket.bootstrap.iter().cloned().collect();
        info!(?bootstrap, "joining {topic_id}");
        let gossip_topic = self.gossip.subscribe(topic_id, bootstrap).await?;
        let (sender, receiver) = gossip_topic.split();

        let nickname = Arc::new(Mutex::new(nickname));
        let trigger_presence = Arc::new(Notify::new());

        // We spawn a task that occasionally sens a Presence message with our nickname.
        // This allows to track which peers are online currently.
        let sender = Arc::new(TokioMutex::new(sender));
        let presence_task = AbortOnDropHandle::new(task::spawn({
            let secret_key = self.secret_key.clone();
            let sender = sender.clone();
            let trigger_presence = trigger_presence.clone();
            let nickname = nickname.clone();

            async move {
                loop {
                    let nickname = nickname.lock().expect("poisened").clone();
                    let message = Message::Presence { nickname };
                    debug!("send presence {message:?}");
                    let signed_message = SignedMessage::sign_and_encode(&secret_key, message)
                        .expect("failed to encode message");
                    if let Err(err) = sender.lock().await.broadcast(signed_message.into()).await {
                        tracing::warn!("presence task failed to broadcast: {err}");
                        break;
                    }
                    n0_future::future::race(
                        n0_future::time::sleep(PRESENCE_INTERVAL),
                        trigger_presence.notified(),
                    )
                    .await;
                }
            }
        }));

        // We create a stream of events, coming from the gossip topic event receiver.
        // We'll want to map the events to our own event type, which includes parsing
        // the messages and verifying the signatures, and trigger presence
        // once the swarm is joined initially.
        let receiver = n0_future::stream::try_unfold(receiver, {
            let trigger_presence = trigger_presence.clone();
            move |mut receiver| {
                let trigger_presence = trigger_presence.clone();
                async move {
                    loop {
                        // Store if we were joined before the next event comes in.
                        let was_joined = receiver.is_joined();

                        // Fetch the next event.
                        let Some(event) = receiver.try_next().await? else {
                            return Ok(None);
                        };
                        // Convert into our event type. this fails if we receive a message
                        // that cannot be decoced into our event type. If that is the case,
                        // we just keep and log the error.
                        let event: Event = match event.try_into() {
                            Ok(event) => event,
                            Err(err) => {
                                warn!("received invalid message: {err}");
                                continue;
                            }
                        };
                        // If we just joined, trigger sending our presence message.
                        if !was_joined && receiver.is_joined() {
                            trigger_presence.notify_waiters()
                        };

                        break Ok(Some((event, receiver)));
                    }
                }
            }
        });

        let sender = ChatSender {
            secret_key: self.secret_key.clone(),
            nickname,
            sender,
            trigger_presence,
            _presence_task: Arc::new(presence_task),
        };
        Ok((sender, Box::pin(receiver)))
    }

    pub async fn shutdown(&self) {
        if let Err(err) = self.router.shutdown().await {
            warn!("failed to shutdown router cleanly: {err}");
        }
        self.router.endpoint().close().await;
    }
}

#[derive(Debug, Clone)]
pub struct ChatSender {
    nickname: Arc<Mutex<String>>,
    secret_key: SecretKey,
    sender: Arc<TokioMutex<GossipSender>>,
    trigger_presence: Arc<Notify>,
    _presence_task: Arc<AbortOnDropHandle<()>>,
}

impl ChatSender {
    pub async fn send(&self, text: String) -> Result<()> {
        let nickname = self.nickname.lock().expect("poisened").clone();
        let message = Message::Message { text, nickname };
        let signed_message = SignedMessage::sign_and_encode(&self.secret_key, message)?;
        self.sender
            .lock()
            .await
            .broadcast(signed_message.into())
            .await?;
        Ok(())
    }

    pub fn set_nickname(&self, name: String) {
        *self.nickname.lock().expect("poisened") = name;
        self.trigger_presence.notify_waiters();
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum Event {
    #[serde(rename_all = "camelCase")]
    Joined {
        neighbors: Vec<NodeId>,
    },
    #[serde(rename_all = "camelCase")]
    MessageReceived {
        from: NodeId,
        text: String,
        nickname: String,
        sent_timestamp: u64,
    },
    #[serde(rename_all = "camelCase")]
    Presence {
        from: NodeId,
        nickname: String,
        sent_timestamp: u64,
    },
    #[serde(rename_all = "camelCase")]
    NeighborUp {
        node_id: NodeId,
    },
    #[serde(rename_all = "camelCase")]
    NeighborDown {
        node_id: NodeId,
    },
    Lagged,
}

impl TryFrom<GossipEvent> for Event {
    type Error = anyhow::Error;
    fn try_from(event: GossipEvent) -> Result<Self, Self::Error> {
        let converted = match event {
            GossipEvent::NeighborUp(node_id) => Self::NeighborUp { node_id },
            GossipEvent::NeighborDown(node_id) => Self::NeighborDown { node_id },
            GossipEvent::Received(message) => {
                let message = SignedMessage::verify_and_decode(&message.content)
                    .context("failed to parse and verify signed message")?;
                match message.message {
                    Message::Presence { nickname } => Self::Presence {
                        from: message.from,
                        nickname,
                        sent_timestamp: message.timestamp,
                    },
                    Message::Message { text, nickname } => Self::MessageReceived {
                        from: message.from,
                        text,
                        nickname,
                        sent_timestamp: message.timestamp,
                    },
                }
            }
            GossipEvent::Lagged => Self::Lagged,
        };
        Ok(converted)
    }
}

#[derive(Debug, Serialize, Deserialize)]
struct SignedMessage {
    from: PublicKey,
    data: Vec<u8>,
    signature: Signature,
}

impl SignedMessage {
    pub fn verify_and_decode(bytes: &[u8]) -> Result<ReceivedMessage> {
        let signed_message: Self = postcard::from_bytes(bytes)?;
        let key: PublicKey = signed_message.from;
        key.verify(&signed_message.data, &signed_message.signature)?;
        let message: WireMessage = postcard::from_bytes(&signed_message.data)?;
        let WireMessage::VO { timestamp, message } = message;
        Ok(ReceivedMessage {
            from: signed_message.from,
            timestamp,
            message,
        })
    }

    pub fn sign_and_encode(secret_key: &SecretKey, message: Message) -> Result<Vec<u8>> {
        let timestamp = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap()
            .as_micros() as u64;
        let wire_message = WireMessage::VO { timestamp, message };
        let data = postcard::to_stdvec(&wire_message)?;
        let signature = secret_key.sign(&data);
        let from: PublicKey = secret_key.public();
        let signed_message = Self {
            from,
            data,
            signature,
        };
        let encoded = postcard::to_stdvec(&signed_message)?;
        Ok(encoded)
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub enum WireMessage {
    VO { timestamp: u64, message: Message },
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Message {
    Presence { nickname: String },
    Message { text: String, nickname: String },
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ReceivedMessage {
    timestamp: u64,
    from: NodeId,
    message: Message,
}

================
File: browser-chat/shared/.gitignore
================
/target

================
File: browser-chat/shared/Cargo.toml
================
[package]
name = "chat-shared"
version = "0.1.0"
edition = "2024"

[dependencies]
anyhow = "1"
blake3 = { version = "1", package = "iroh-blake3" }
hex = "0.4"
iroh = { workspace = true }
iroh-base = { workspace = true, default-features = false, features = ["ticket"] }
iroh-gossip = { workspace = true, default-features = false, features = ["net"] }
n0-future = "0.1.2"
postcard = "1.1.1"
rand = "0.8"
serde = "1"
tokio = { version = "1", default-features = false, features = ["sync"] }
tracing = "0.1"

[package.metadata.wasm-pack.profile.release]
wasm-opt = ["--enable-nontrapping-float-to-int", "--enable-bulk-memory"]

================
File: browser-chat/Cargo.toml
================
[workspace]
resolver = "2"
members = ["shared", "cli", "browser-wasm"]

[workspace.dependencies]
# we define iroh dependencies here to make upgrading easier.
iroh = { version = "0.90", default-features = false }
iroh-base = { version = "0.90", default-features = false, features = ["ticket"] }
iroh-gossip = { version = "0.90", default-features = false, features = ["net"] }

================
File: browser-chat/Makefile.toml
================
# Use cargo-make to run tasks here: https://crates.io/crates/cargo-make

[tasks.deploy]
workspace = false
script = '''
cd frontend
npm run build:wasm:release
npm install
npm run build
'''

================
File: browser-chat/README.md
================
# browser-chat

This is a chat app that runs in both the browser and the command line. It uses [`iroh-gossip`](https://github.com/n0-computer/iroh-gossip/) to send messages between peers sharing a channel.

We automatically deploy this example, you can **[try it out here](https://n0-computer.github.io/iroh-examples/main/browser-chat/index.html)**.

The example has the following parts:

* [**shared**](shared) is a Rust library that exposes a `ChatNode`, which uses iroh and iroh-gossip to power a simple ephemeral gossip chat between peers.
* [**cli**](cli) uses that library to create a simple command-line chat app.
* [**browser-wasm**](browser-wasm) is a wrapper around the shared library that uses [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen) to export JavaScript bindings.
* [**frontend**](frontend) is the web app. It is written in [TypeScript](https://www.typescriptlang.org/) and uses [React](https://react.dev/) and [shadcn components](https://ui.shadcn.com/).
  It is built and bundled with [Vite](https://vite.dev/).

## Web app

Follow the steps below to build and run the browser version of the chat app.

### Requirements

To build the example, you need a Rust toolchain for `wasm32-unknown-unknown`, [`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen) and [`wasm-pack`](https://github.com/rustwasm/wasm-pack).

```
rustup target install wasm32-unknown-unknown
cargo binstall wasm-bindgen-cli wasm-pack
```
`cargo binstall` is a nifty little tool that downloads binaries from Github releases matching your system architecture. If you don't have it yet, first [install it](https://github.com/cargo-bins/cargo-binstall?tab=readme-ov-file#quickly).

### Building for development

To build the chat app in development mode, run these commands:
```
cd frontend
npm run build:wasm
npm install
npm run dev
```

And then open [`http://localhost:5173`](http://localhost:5173) in your browser.

Note that you have to run `npm run build:wasm` *before* running `npm install`.
`build:wasm` is an alias defined in [`frontend/package.json`](frontend/package.json) that builds and packs the [`browser-wasm` crate](browser-wasm) with [`wasm-pack`](https://rustwasm.github.io/wasm-pack/).
Spelled out:

```
wasm-pack build ./browser-wasm --dev --weak-refs --reference-types -t bundler -d pkg
```
This builds the `browser-wasm` for the `wasm32-unknown-unknown` target, creates the JavaScript bindings with `wasm-bindgen`, and wraps it into an NPM package ready to be used by common frontend bundling tools (like Vite in our chat app frontend).

The frontend package has a `file:` dependency onto the Wasm package created by `wasm-pack`.
Whenever you change something on the rust side, you need to rebuild the Wasm package with `npm run build:wasm` (or the `wasm-pack` command).
Likely you will have to restart the Vite dev server afterwards, as the Wasm is not properly picked up by Vite's hot module reloader.

### Building for production

To build for production, run these commands:
```
cd frontend
npm run build:wasm:release
npm run build
```

You will find the output (HTML and assets) in the `frontend/dist` folder.

The `build:wasm:release` command is an alias to `wasm-pack` in release mode. We also have a custom profile definition for the release build
that includes optimizations to reduce the Wasm size (see [`.cargo/config.toml`](browser-wasm/.cargo/config.toml)).

## Command-line app

To run the CLI version of our chat app, simply run `cargo run` from this folder. It will print help text on how to create or join channels.

================
File: browser-chat/tsconfig.json
================
{
  "files": [],
  "references": [{ "path": "./frontend" }]
}

================
File: browser-echo/.cargo/config.toml
================
[target.wasm32-unknown-unknown]
rustflags = ['--cfg', 'getrandom_backend="wasm_js"']

================
File: browser-echo/public/index.html
================
<!doctype html>
<html>
    <head>
        <title>Iroh browser echo demo</title>
        <script src="./main.js" type="module"></script>
        <link rel="stylesheet" href="./style.css" />
    </head>

    <body>
        <header>
            <h1>
                iroh in the browser
            </h1>
            This example runs iroh in the browser, compiled to web assembly. The example uses a custom <i>Echo protocol</i>: You connect to remote node, send some data, and the remote node sends back the same data.
            The protocol may be used both from the browser and from the command line, and browser and cli nodes can connect to each other.
            <br>
            <a href="https://github.com/n0-computer/iroh-examples/tree/main/browser-echo" target="_blank">
                Source code
            </a>
        </header>
        <main></main>
        <div class="spawned" style="display:none">
        <form id="connect">
            <h3>connect to another node</h3>
            <div class="fields">
                <div>
                <label for="node-id">node id to connect to:</label>
                <input name="node-id" placeholder="node id" />
                </div>
                <div>
                <label for="payload">text to send to the node:</label>
                <input name="payload" placeholder="string to send" />
                </div>
            </div>
            <div>
            <button type="submit">connect</button>
            </div>
          </form>
        <div id="outgoing" class="connections"">
            <h2>outgoing connections</h2>
        </div>
        <div id="incoming" class="connections"">
            <h2>incoming connections</h2>
        </div>
        </div>
    </body>
</html>

================
File: browser-echo/public/main.js
================
import init, { EchoNode } from "./wasm/browser_echo.js";
await init();

log("launching iroh endpoint ");

const node = await EchoNode.spawn();

log("iroh endpoint launched");
log("our node id: " + node.node_id());

log("connect from the command line:");
log("git clone https://github.com/n0-computer/iroh-examples.git", "cmd");
log("cd iroh-examples/browser-echo", "cmd");
log(
  `cargo run --features cli -- connect ${node.node_id()} "hi from cli"`,
  "cmd",
);
const link = createConnectLink(node.node_id(), "hi from browser");
log(`connect from the browser: ${link}`);
log("waiting for connections ");

// show the form and connection logs
document.querySelector(".spawned").style = "display: block";
// initiate outgoing connections on form submit
document.querySelector("form#connect").onsubmit = onConnectSubmit;
// fill the connect form
fillFormFromUrlAndSubmit();

// log events for incoming connections
(async () => {
  const $incoming = document.querySelector("#incoming");
  for await (const event of node.events()) {
    console.log("incoming event", event);
    const nodeId = event.node_id;
    delete event.node_id;
    logNodeEvent($incoming, nodeId, JSON.stringify(event));
  }
})();

// initiate outgoing connections on form submit
async function onConnectSubmit(e) {
  e.preventDefault();
  const data = new FormData(e.target);
  const nodeId = data.get("node-id");
  const payload = data.get("payload");
  if (!nodeId || !payload) return;

  const $outgoing = document.querySelector("#outgoing");
  try {
    logNodeEvent($outgoing, nodeId, "connecting ");
    const stream = node.connect(nodeId, payload);
    for await (const event of stream) {
      logNodeEvent($outgoing, nodeId, JSON.stringify(event));
    }
  } catch (err) {
    logNodeEvent($outgoing, nodeId, `connection failed: ${err}`, "error");
  }
}

function log(line, className, parent) {
  const time = new Date().toISOString().substring(11, 22);
  if (!parent) parent = document.querySelector("main");
  const el = document.createElement("div");
  line = `<span class=time>${time}: </span>${line}`;
  el.innerHTML = line;
  if (className) el.classList.add(className);
  parent.appendChild(el);
}

function logNodeEvent(container, nodeId, event, className) {
  let nodeDiv = container.querySelector(`.node-${nodeId}`);
  if (!nodeDiv) {
    nodeDiv = document.createElement("div");
    nodeDiv.classList.add("node");
    nodeDiv.classList.add(`node-${nodeId}`);
    const heading = document.createElement("h3");
    heading.innerText = nodeId;
    nodeDiv.appendChild(heading);
    container.appendChild(nodeDiv);
  }
  log(`${event}`, className, nodeDiv);
}

function fillFormFromUrlAndSubmit() {
  const $form = document.querySelector("form#connect");
  const url = new URL(document.location);
  $form.querySelector("[name=node-id]").value =
    url.searchParams.get("connect") || "";
  $form.querySelector("[name=payload]").value =
    url.searchParams.get("payload") || "";
  document.querySelector("form#connect").requestSubmit();
}

function createConnectLink(nodeId, payload) {
  const ourUrl = new URL(document.location);
  ourUrl.searchParams.set("connect", nodeId);
  ourUrl.searchParams.set("payload", payload);
  return `<a href="${ourUrl}" target="_blank">click here</a>`;
}

================
File: browser-echo/public/style.css
================
body {
    margin: 0;
    padding: 2rem;
    color: #eee;
    background: #222;
    font-family: ui-monospace, Menlo, "Cascadia Mono", "Segoe UI Mono",
        "Roboto Mono", "Source Code Pro", monospace;
    font-size: 16px;
    line-height: 1.4;
}

* {
    box-sizing: border-box;
}

header,
main,
.connections,
form {
    max-width: 80rem;
    padding: 0.5rem;
    margin: 0.5rem;
}

.error {
    color: #f9a;
}

.cmd {
    padding-left: 8rem;
    color: #bda;
    font-size: 0.9rem;
}
.cmd .time {
    display: none;
}

a {
    color: #eac;
}

form {
    color: #888;
    background: #333;
}
form .fields {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-gap: 1rem;
    margin: .5rem 0;
}
form h3 {
    grid-co
}
label {
    display: block;
}

input,
button {
    background: #33222f;
    padding: 0.5rem;
    color: #fff;
    border: 1px solid #735;
    font-family: inherit;
    font-size: 0.9rem;
}

input:focus,
button:focus,
button:hover,
button:active {
    outline: none;
    border-color: #957;
    background: #44333f;
}

input {
    width: 100%;
}

.time {
    font-size: 0.9rem;
    color: #888;
}

.node {
}

.node h3 {
    font-size: 1rem;
    font-weight: bold;
    margin: 0;
    padding: 0;
    color: #dac;
}

.connections {
    margin: 0.5rem;
    padding: 0.5rem;
    background: #333;
}

h2, h3 {
    color: #999;
    font-size: 1rem;
    font-weight: bold;
    margin: 0;
    padding: 0;
}

h1 {
    font-size: 1.2rem;
    color: #eac;
    margin: 0 0 1rem 0;
    padding: 0;
}

================
File: browser-echo/src/bin/cli.rs
================
use anyhow::Result;
use browser_echo::node::EchoNode;
use clap::Parser;
use iroh::NodeId;
use n0_future::StreamExt;

#[derive(Debug, Parser)]
struct Args {
    #[clap(subcommand)]
    command: Command,
}

#[derive(Debug, Parser)]
enum Command {
    Connect { node_id: NodeId, payload: String },
    Accept,
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt::init();
    let args = Args::parse();
    let node = EchoNode::spawn().await?;
    match args.command {
        Command::Connect { node_id, payload } => {
            let mut events = node.connect(node_id, payload);
            while let Some(event) = events.next().await {
                println!("event {event:?}");
            }
        }
        Command::Accept => {
            println!("connect to this node:");
            println!(
                "cargo run -- connect {} hello-please-echo-back",
                node.endpoint().node_id()
            );
            let mut events = node.accept_events();
            while let Some(event) = events.next().await {
                println!("event {event:?}");
            }
        }
    }

    Ok(())
}

================
File: browser-echo/src/lib.rs
================
pub mod node;

#[cfg(all(target_family = "wasm", target_os = "unknown"))]
pub mod wasm;

================
File: browser-echo/src/node.rs
================
use anyhow::Result;
use async_channel::Sender;
use iroh::{
    Endpoint, NodeId,
    endpoint::Connection,
    protocol::{AcceptError, ProtocolHandler, Router},
};
use n0_future::{Stream, StreamExt, boxed::BoxStream, task};
use serde::{Deserialize, Serialize};
use tokio::sync::broadcast;
use tokio_stream::wrappers::BroadcastStream;
use tracing::info;

#[derive(Debug, Clone)]
pub struct EchoNode {
    router: Router,
    accept_events: broadcast::Sender<AcceptEvent>,
}

impl EchoNode {
    pub async fn spawn() -> Result<Self> {
        let endpoint = iroh::Endpoint::builder()
            .discovery_n0()
            .alpns(vec![Echo::ALPN.to_vec()])
            .bind()
            .await?;
        let (event_sender, _event_receiver) = broadcast::channel(128);
        let echo = Echo::new(event_sender.clone());
        let router = Router::builder(endpoint).accept(Echo::ALPN, echo).spawn();
        Ok(Self {
            router,
            accept_events: event_sender,
        })
    }

    pub fn endpoint(&self) -> &Endpoint {
        self.router.endpoint()
    }

    pub fn accept_events(&self) -> BoxStream<AcceptEvent> {
        let receiver = self.accept_events.subscribe();
        Box::pin(BroadcastStream::new(receiver).filter_map(|event| event.ok()))
    }

    pub fn connect(
        &self,
        node_id: NodeId,
        payload: String,
    ) -> impl Stream<Item = ConnectEvent> + Unpin + use<> {
        let (event_sender, event_receiver) = async_channel::bounded(16);
        let endpoint = self.router.endpoint().clone();
        task::spawn(async move {
            let res = connect(&endpoint, node_id, payload, event_sender.clone()).await;
            let error = res.as_ref().err().map(|err| err.to_string());
            event_sender.send(ConnectEvent::Closed { error }).await.ok();
        });
        Box::pin(event_receiver)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum ConnectEvent {
    Connected,
    Sent { bytes_sent: u64 },
    Received { bytes_received: u64 },
    Closed { error: Option<String> },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "camelCase")]
pub enum AcceptEvent {
    Accepted {
        node_id: NodeId,
    },
    Echoed {
        node_id: NodeId,
        bytes_sent: u64,
    },
    Closed {
        node_id: NodeId,
        error: Option<String>,
    },
}

#[derive(Debug, Clone)]
pub struct Echo {
    event_sender: broadcast::Sender<AcceptEvent>,
}

impl Echo {
    pub const ALPN: &[u8] = b"iroh/example-browser-echo/0";
    pub fn new(event_sender: broadcast::Sender<AcceptEvent>) -> Self {
        Self { event_sender }
    }
}

impl Echo {
    async fn handle_connection(
        self,
        connection: Connection,
    ) -> std::result::Result<(), AcceptError> {
        // Wait for the connection to be fully established.
        let node_id = connection.remote_node_id()?;
        self.event_sender
            .send(AcceptEvent::Accepted { node_id })
            .ok();
        let res = self.handle_connection_0(&connection).await;
        let error = res.as_ref().err().map(|err| err.to_string());
        self.event_sender
            .send(AcceptEvent::Closed { node_id, error })
            .ok();
        res
    }
    async fn handle_connection_0(
        &self,
        connection: &Connection,
    ) -> std::result::Result<(), AcceptError> {
        // We can get the remote's node id from the connection.
        let node_id = connection.remote_node_id()?;
        info!("Accepted connection from {node_id}");

        // Our protocol is a simple request-response protocol, so we expect the
        // connecting peer to open a single bi-directional stream.
        let (mut send, mut recv) = connection.accept_bi().await?;

        // Echo any bytes received back directly.
        let bytes_sent = tokio::io::copy(&mut recv, &mut send).await?;
        info!("Copied over {bytes_sent} byte(s)");
        self.event_sender
            .send(AcceptEvent::Echoed {
                node_id,
                bytes_sent,
            })
            .ok();

        // By calling `finish` on the send stream we signal that we will not send anything
        // further, which makes the receive stream on the other end terminate.
        send.finish()?;

        // Wait until the remote closes the connection, which it does once it
        // received the response.
        connection.closed().await;
        Ok(())
    }
}

impl ProtocolHandler for Echo {
    /// The `accept` method is called for each incoming connection for our ALPN.
    ///
    /// The returned future runs on a newly spawned tokio task, so it can run as long as
    /// the connection lasts.
    async fn accept(&self, connection: Connection) -> std::result::Result<(), AcceptError> {
        self.clone().handle_connection(connection).await
    }
}

async fn connect(
    endpoint: &Endpoint,
    node_id: NodeId,
    payload: String,
    event_sender: Sender<ConnectEvent>,
) -> Result<()> {
    let connection = endpoint.connect(node_id, Echo::ALPN).await?;
    event_sender.send(ConnectEvent::Connected).await?;
    let (mut send_stream, mut recv_stream) = connection.open_bi().await?;
    let send_task = task::spawn({
        let event_sender = event_sender.clone();
        async move {
            let bytes_sent = payload.len();
            send_stream.write_all(payload.as_bytes()).await?;
            event_sender
                .send(ConnectEvent::Sent {
                    bytes_sent: bytes_sent as u64,
                })
                .await?;
            anyhow::Ok(())
        }
    });
    let n = tokio::io::copy(&mut recv_stream, &mut tokio::io::sink()).await?;
    // We know we received the last data, so we close the connection.
    connection.close(1u8.into(), b"done");
    event_sender
        .send(ConnectEvent::Received {
            bytes_received: n as u64,
        })
        .await?;
    send_task.await??;
    Ok(())
}

================
File: browser-echo/src/wasm.rs
================
use anyhow::{Context, Result};
use n0_future::{Stream, StreamExt};
use serde::Serialize;
use tracing::level_filters::LevelFilter;
use tracing_subscriber_wasm::MakeConsoleWriter;
use wasm_bindgen::{JsError, JsValue, prelude::wasm_bindgen};
use wasm_streams::{ReadableStream, readable::sys::ReadableStream as JsReadableStream};

use crate::node;

#[wasm_bindgen(start)]
fn start() {
    console_error_panic_hook::set_once();

    tracing_subscriber::fmt()
        .with_max_level(LevelFilter::TRACE)
        .with_writer(
            // To avoide trace events in the browser from showing their JS backtrace
            MakeConsoleWriter::default().map_trace_level_to(tracing::Level::DEBUG),
        )
        // If we don't do this in the browser, we get a runtime error.
        .without_time()
        .with_ansi(false)
        .init();

    tracing::info!("(testing logging) Logging setup");
}

#[wasm_bindgen]
pub struct EchoNode(node::EchoNode);

#[wasm_bindgen]
impl EchoNode {
    pub async fn spawn() -> Result<Self, JsError> {
        Ok(Self(node::EchoNode::spawn().await.map_err(to_js_err)?))
    }

    pub fn events(&self) -> JsReadableStream {
        let stream = self.0.accept_events();
        into_js_readable_stream(stream)
    }

    pub fn node_id(&self) -> String {
        self.0.endpoint().node_id().to_string()
    }

    pub fn connect(&self, node_id: String, payload: String) -> Result<JsReadableStream, JsError> {
        let node_id = node_id
            .parse()
            .context("failed to parse node id")
            .map_err(to_js_err)?;
        let stream = self.0.connect(node_id, payload);
        Ok(into_js_readable_stream(stream))
    }

    pub fn remote_info(&self) -> Vec<JsValue> {
        self.0
            .endpoint()
            .remote_info_iter()
            .map(|info| serde_wasm_bindgen::to_value(&info).unwrap())
            .collect::<Vec<_>>()
    }
}

fn to_js_err(err: impl Into<anyhow::Error>) -> JsError {
    let err: anyhow::Error = err.into();
    JsError::new(&err.to_string())
}

fn into_js_readable_stream<T: Serialize>(
    stream: impl Stream<Item = T> + 'static,
) -> wasm_streams::readable::sys::ReadableStream {
    let stream = stream.map(|event| Ok(serde_wasm_bindgen::to_value(&event).unwrap()));
    ReadableStream::from_stream(stream).into_raw()
}

================
File: browser-echo/.gitignore
================
/public/wasm
/package-lock.json
/node_modules

================
File: browser-echo/Cargo.toml
================
[package]
name = "browser-echo"
version = "0.1.0"
edition = "2024"
default-run = "cli"

[lib]
crate-type = ["cdylib", "rlib"]

[[bin]]
name = "cli"
required-features = ["cli"]

[dependencies]
anyhow = "1.0.86"
async-channel = "2.3.1"
clap = { version = "4.5.30", features = ["derive"], optional = true }
console_error_panic_hook = "0.1.7"
getrandom = { version = "0.3", features = ["wasm_js"] }
iroh = { version = "0.90", default-features = false }
n0-future = "0.1.2"
serde = "1.0.217"
serde-wasm-bindgen = "0.6.5"
tokio = { version = "1.43.0", default-features = false, features = ["sync"] }
tokio-stream = { version = "0.1.17", default-features = false, features = ["sync"] }
tracing = "0.1.40"
tracing-subscriber = { version = "0.3.18", features = ["env-filter"] }
tracing-subscriber-wasm = "0.1.0"
wasm-bindgen = "=0.2.100"
wasm-bindgen-futures = "0.4.50"
wasm-streams = "0.4.2"

[features]
cli = ["tokio/full", "dep:clap"]

[profile.release]
codegen-units = 1
strip = "symbols"
debug = false
lto = true
opt-level = "z"
panic = 'abort'

================
File: browser-echo/Makefile.toml
================
# Use cargo-make to run tasks here: https://crates.io/crates/cargo-make

[tasks.deploy]
command = "npm"
args = ["run", "build:release"]

================
File: browser-echo/package.json
================
{
  "name": "browser-iroh-demo",
  "version": "0.1.0",
  "scripts": {
    "build": "cargo build --target=wasm32-unknown-unknown && wasm-bindgen ./target/wasm32-unknown-unknown/debug/browser_echo.wasm --out-dir=public/wasm --weak-refs --target=web --debug",
    "build:release": "cargo build --target=wasm32-unknown-unknown --release && wasm-bindgen ./target/wasm32-unknown-unknown/release/browser_echo.wasm --out-dir=public/wasm --weak-refs --target=web && wasm-opt --enable-nontrapping-float-to-int --enable-bulk-memory -Os -o public/wasm/browser_echo_bg.wasm public/wasm/browser_echo_bg.wasm",
    "serve": "http-server --cors -a localhost public/"
  },
  "author": "n0 team",
  "license": "Apache-2.0 OR MIT",
  "dependencies": {
    "http-server": "^14.1.1"
  }
}

================
File: browser-echo/README.md
================
# iroh browser echo demo

This example runs iroh in the browser, compiled to web assembly. The example uses a custom *Echo protocol*: You connect to remote node, send some data, and the remote node sends back the same data. The protocol may be used both from the browser and from the command line, and browser and cli nodes can connect to each other.

The protocol and setup code is shared between the browser and the CLI.

## Run the browser version:

You can try out the **[deployed example](https://n0-computer.github.io/iroh-examples/main/browser-echo/index.html)**.
To build and run it yourself, follow these steps:

```sh
$ cargo install wasm-bindgen-cli
$ rustup target install wasm32-unknown-unknown
$ npm install
$ npm run build
$ npm run serve
```

Then, open [`http://localhost:8080`](http://localhost:8080). The app will print instructions on how to connect and accept connections.

To build in release mode and apply optimizations to reduce the wasm size, run `npm run build:release` instead.

## Run the CLI version:

To accept connections:
```sh
cargo run --features cli -- accept
```

To initiate a connection:
```sh
cargo run --features cli -- connect <NODE-ID> <PAYLOAD>
```

## Navigate the code

This folder contains a single Rust crate that can be compiled to both webassembly for the browser and to a commad line.

* The shared code between WASM and CLI lives in [`src/node.rs`](src/node.rs).
* A WASM-only wrapper around the `EchoNode` defined there lives in [`src/wasm.rs`](src/wasm.rs).
  It mostly is concerned with converting types to browser-supported equivalents.
* The CLI binary lives in [`src/bin/cli.rs`](src/bin/cli.rs)

Apart from the rust crate, we have a little HTML, CSS and JavaScript for the demo app. There's no further external dependencies used.
The code lives in [`public`].

Running `npm run build` first compiles the crate to WASM, then creates the JavaScript browser bindings with `wasm-bindgen`,
and puts the result into `public/wasm`, from where the wasm is imported in the [`main.js`](public/main.js).

================
File: dumbpipe-web/src/main.rs
================
use std::{
    net::{SocketAddrV4, SocketAddrV6},
    str::FromStr,
    sync::OnceLock,
};

use anyhow::Context;
use bytes::Bytes;
use clap::Parser;
use http_body_util::{BodyExt, Full, combinators::BoxBody};
use hyper::client::conn::http1::Builder;
use hyper::server::conn::http1;
use hyper::service::service_fn;
use hyper::{Request, Response};

use hyper_util::rt::TokioIo;
use iroh::{Endpoint, NodeAddr, SecretKey};
use tokio::net::TcpListener;

#[derive(Parser, Debug)]
pub struct Args {
    /// The addresses to listen on for incoming tcp connections.
    ///
    /// To listen on all network interfaces, use 0.0.0.0:12345
    #[clap(long, default_value = "0.0.0.0:8080")]
    pub addr: String,

    /// The address to use for the ipv4 iroh socket. Random by default.
    #[clap(long, default_value = None)]
    pub iroh_ipv4_addr: Option<SocketAddrV4>,

    /// The address to use for the ipv6 iroh socket. Random by default.
    #[clap(long, default_value = None)]
    pub iroh_ipv6_addr: Option<SocketAddrV6>,
}

/// Get the secret key or generate a new one.
///
/// Print the secret key to stderr if it was generated, so the user can save it.
fn get_or_create_secret() -> anyhow::Result<SecretKey> {
    match std::env::var("IROH_SECRET") {
        Ok(secret) => SecretKey::from_str(&secret).context("invalid secret"),
        Err(_) => {
            let key = SecretKey::generate(rand::thread_rng());
            let key_str = hex::encode(key.to_bytes());
            eprintln!("using secret key {key_str}");
            Ok(key)
        }
    }
}

mod quinn_endpoint;

/// global iroh endpoint
static ENDPOINT: OnceLock<Endpoint> = OnceLock::new();
fn endpoint() -> &'static Endpoint {
    ENDPOINT.get().unwrap()
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt::init();
    let args = Args::parse();
    let secret_key = get_or_create_secret()?;
    // Create a iroh endpoint and set it as a global
    //
    // Done explicitly here because creation is async
    let mut builder = Endpoint::builder().secret_key(secret_key).discovery_n0();
    if let Some(addr) = args.iroh_ipv4_addr {
        builder = builder.bind_addr_v4(addr);
    }
    if let Some(addr) = args.iroh_ipv6_addr {
        builder = builder.bind_addr_v6(addr);
    }
    let endpoint = builder.bind().await?;
    ENDPOINT.set(endpoint).expect("endpoint already set");

    // Create a tokio TCP listener for hyper
    let listener = TcpListener::bind(args.addr).await?;
    let local_addr = listener.local_addr()?;
    eprintln!("Listening on http://{local_addr}");
    tracing::info!("Listening on http://{}", local_addr);

    loop {
        let (stream, remote_addr) = match listener.accept().await {
            Ok(x) => x,
            Err(err) => {
                tracing::warn!("failed to accept connection: {:?}", err);
                continue;
            }
        };
        tracing::info!("accepted connection from {remote_addr}");
        tokio::task::spawn(async move {
            if let Err(err) = http1::Builder::new()
                .preserve_header_case(true)
                .title_case_headers(true)
                .serve_connection(TokioIo::new(stream), service_fn(proxy))
                .with_upgrades()
                .await
            {
                tracing::warn!("Failed to serve connection: {:?}", err);
            }
        });
    }
}

fn bad_request(text: &'static str) -> anyhow::Result<Response<BoxBody<Bytes, hyper::Error>>> {
    let mut resp: Response<BoxBody<Bytes, hyper::Error>> = Response::new(full(text));
    *resp.status_mut() = http::StatusCode::BAD_REQUEST;
    Ok(resp)
}

fn parse_subdomain(subdomain: &str) -> anyhow::Result<NodeAddr> {
    // first try to parse as a node id
    if let Ok(node_id) = iroh::NodeId::from_str(subdomain) {
        return Ok(NodeAddr {
            node_id,
            relay_url: None, // Use discovery
            direct_addresses: Default::default(),
        });
    }
    // then try to parse as a node ticket
    if let Ok(ticket) = dumbpipe::NodeTicket::from_str(subdomain) {
        return Ok(ticket.node_addr().clone());
    }
    Err(anyhow::anyhow!("invalid subdomain"))
}

async fn proxy(
    req: Request<hyper::body::Incoming>,
) -> anyhow::Result<Response<BoxBody<Bytes, hyper::Error>>> {
    let (_, hostname) = req
        .headers()
        .iter()
        .find(|(name, _value)| name.as_str() == "host")
        .context("missing host header")
        .context(http::StatusCode::BAD_REQUEST)?;
    let Ok(hostname) = hostname.to_str() else {
        return bad_request("invalid host header - not ascii");
    };
    let parts = hostname.split('.').collect::<Vec<_>>();
    if parts.len() < 2 {
        return bad_request("invalid host header - missing subdomain");
    }
    let Ok(node_addr) = parse_subdomain(parts[0]) else {
        return bad_request("invalid host header - subdomain is neither a node id nor a ticket");
    };
    tracing::info!("connecting to node: {:?}", node_addr);
    let conn = endpoint().connect(node_addr, dumbpipe::ALPN).await?;
    tracing::info!("opening bi stream");
    let (mut send, recv) = conn.open_bi().await?;
    tracing::info!("sending handshake");
    send.write_all(&dumbpipe::HANDSHAKE).await?;
    let stream = quinn_endpoint::QuinnEndpoint { send, recv };
    let io = TokioIo::new(stream);

    let (mut sender, conn) = Builder::new()
        .preserve_header_case(true)
        .title_case_headers(true)
        .handshake(io)
        .await?;
    tokio::task::spawn(async move {
        if let Err(err) = conn.await {
            tracing::warn!("Connection failed: {:?}", err);
        }
    });

    let resp = sender.send_request(req).await?;
    Ok(resp.map(|b| b.boxed()))
}

fn full<T: Into<Bytes>>(chunk: T) -> BoxBody<Bytes, hyper::Error> {
    Full::new(chunk.into())
        .map_err(|never| match never {})
        .boxed()
}

================
File: dumbpipe-web/src/quinn_endpoint.rs
================
//! QuinnEndpoint is a wrapper around a quinn::SendStream and quinn::RecvStream
//!
//! It implements AsyncRead and AsyncWrite so it can be used with tokio::io::copy
use iroh::endpoint::{RecvStream, SendStream};
use std::pin::Pin;
use std::task::{Context, Poll};
use tokio::io::{AsyncRead, AsyncWrite, ReadBuf};

pub struct QuinnEndpoint {
    pub send: SendStream,
    pub recv: RecvStream,
}

impl AsyncRead for QuinnEndpoint {
    fn poll_read(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &mut ReadBuf,
    ) -> Poll<std::io::Result<()>> {
        let self_mut = self.get_mut();
        Pin::new(&mut self_mut.recv).poll_read(cx, buf)
    }
}

impl AsyncWrite for QuinnEndpoint {
    fn poll_write(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
        buf: &[u8],
    ) -> Poll<Result<usize, std::io::Error>> {
        let self_mut = self.get_mut();
        let send_poll = Pin::new(&mut self_mut.send).poll_write(cx, buf);
        send_poll.map_err(Into::into)
    }

    fn poll_flush(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), std::io::Error>> {
        let self_mut = self.get_mut();
        let flush_poll = Pin::new(&mut self_mut.send).poll_flush(cx);
        flush_poll.map_err(Into::into)
    }

    fn poll_shutdown(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<Result<(), std::io::Error>> {
        let self_mut = self.get_mut();
        let shutdown_poll = Pin::new(&mut self_mut.send).poll_shutdown(cx);
        shutdown_poll.map_err(Into::into)
    }
}

================
File: dumbpipe-web/Cargo.toml
================
[package]
name = "reverse-proxy"
version = "0.1.0"
edition = "2024"
license = "Apache-2.0/MIT"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
anyhow = "1.0.75"
bytes = "1.5.0"
clap = { version = "4.4.11", features = ["derive"] }
dumbpipe = "0.28"
hex = "0.4.3"
http = "1.0.0"
http-body-util = "0.1.0"
hyper = { version = "1.0.1", features = ["full"] }
hyper-util = { version = "0.1.1", features = ["full"] }
iroh = "0.90"
rand = "0.8.5"
tokio = { version = "1.34.0", features = ["full"] }
tracing = "0.1.40"
tracing-subscriber = { version = "0.3.18", features = ["env-filter"] }

================
File: dumbpipe-web/LICENSE-APACHE
================
Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.

================
File: dumbpipe-web/LICENSE-MIT
================
The MIT License (MIT)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

================
File: dumbpipe-web/README.md
================
# A web frontend for dumbpipe

This forwards http requests to [dumbpipe](https://crates.io/crates/dumbpipe)

You give a node url like `<ticket>.localhost:8080` or `nodeid`.localhost:8000,
and the request will be forwarded to the dumbpipe command running under that
node id.

## Example:

1. Run local dev web server on port 3000:

```
npm run dev
>    - Local:        http://localhost:3000
```

2. Run dumbpipe to make the above accessible

```
dumbpipe listen-tcp --host localhost:3000
```

3. Run this tool

```
cargo run
> Listening on http://0.0.0.0:8080
```

4. Access the website via a browser at

```
http://<ticket>.localhost:8080
```

================
File: extism/host/src/main.rs
================
use extism::*;

fn main() -> anyhow::Result<()> {
    let tokio_rt = tokio::runtime::Builder::new_multi_thread()
        .thread_name("main-runtime")
        .worker_threads(2)
        .enable_all()
        .build()?;
    let rt = tokio_rt.handle().clone();

    let ticket = std::env::args().nth(1).expect("missing ticket");

    let iroh = rt.block_on(async {
        let iroh_path = iroh_extism_host_functions::default_iroh_extism_data_root().await?;
        iroh_extism_host_functions::Iroh::new(iroh_path).await
    })?;
    println!("iroh node id: {:?}", iroh.node_id());

    let file = Wasm::file("../plugin/target/wasm32-unknown-unknown/debug/plugin.wasm");
    let manifest = Manifest::new([file]);

    let plugin = PluginBuilder::new(manifest).with_wasi(true);

    let mut plugin =
        iroh_extism_host_functions::add_all_host_functions(rt, plugin, iroh).build()?;

    let res = plugin
        .call::<&str, &str>("print_hai_and_get_ticket", &ticket)
        .unwrap();

    println!("Received iroh data:\n\n{res}");

    Ok(())
}

================
File: extism/host/Cargo.toml
================
[package]
name = "extism-host"
version = "0.1.0"
edition = "2024"

[dependencies]
anyhow = "1.0.79"
extism = "1.0.0"
tokio = { version = "1", features = ["full"] }
iroh-extism-host-functions = { path = "../iroh-extism-host-functions" }

================
File: extism/iroh-extism-host-functions/src/lib.rs
================
use std::{path::PathBuf, str::FromStr};

use anyhow::{Result, anyhow};
use extism::*;
use futures::stream::StreamExt;
use iroh::{Endpoint, NodeId, protocol::Router};
use iroh_blobs::{api::downloader::Shuffled, net_protocol::Blobs, store::fs::FsStore};

const IROH_EXTISM_DATA_DIR: &str = "iroh-extism";

pub async fn default_iroh_extism_data_root() -> Result<PathBuf> {
    if let Some(val) = std::env::var_os("IROH_EXTISM_DATA_DIR") {
        return Ok(PathBuf::from(val));
    }
    let path = dirs_next::data_dir().ok_or_else(|| {
        anyhow!("operating environment provides no directory for application data")
    })?;

    Ok(path.join(IROH_EXTISM_DATA_DIR))
}

pub struct Iroh {
    router: Router,
    blobs: Blobs,
}

impl Iroh {
    pub async fn new(path: PathBuf) -> Result<Iroh> {
        // create an endpoint
        let endpoint = Endpoint::builder().discovery_n0().bind().await?;

        // create blobs protocol
        let store = FsStore::load(path).await?;

        let blobs = Blobs::new(&store, endpoint.clone(), None);
        // create router
        let router = Router::builder(endpoint)
            .accept(iroh_blobs::ALPN, blobs.clone())
            .spawn();
        Ok(Iroh { router, blobs })
    }

    pub fn node_id(&self) -> NodeId {
        self.router.endpoint().node_id()
    }

    pub fn blobs(&self) -> Blobs {
        self.blobs.clone()
    }

    pub fn router(&self) -> &Router {
        &self.router
    }
}

struct Context {
    rt: tokio::runtime::Handle,
    iroh: Iroh,
}

host_fn!(iroh_blob_get_ticket(user_data: Context; ticket: &str) -> Vec<u8> {
    let ctx = user_data.get()?;
    let ctx = ctx.lock().unwrap();

    let (node_addr, hash, format) = iroh_blobs::ticket::BlobTicket::from_str(ticket).map_err(|_| anyhow!("invalid ticket"))?.into_parts();

    if format != iroh_blobs::BlobFormat::Raw {
        return Err(anyhow!("can only get raw bytes for now, not HashSequences (collections)"));
    }
    let router = ctx.iroh.router();
    let blobs = ctx.iroh.blobs();
    let store = blobs.store();
    let downloader = store.downloader(router.endpoint());
    let buf = ctx.rt.block_on(async move {
        let blobs = store.blobs();
        let mut stream = downloader.download(hash, Shuffled::new(vec![node_addr.node_id])).stream().await?;
        while stream.next().await.is_some() {}

        let buffer = blobs.get_bytes(hash).await?;
        router.shutdown().await?;

        anyhow::Ok(buffer.to_vec())
    })?;

    Ok(buf)
});

pub fn add_all_host_functions(
    rt: tokio::runtime::Handle,
    b: PluginBuilder,
    iroh: Iroh,
) -> PluginBuilder {
    let ctx = UserData::new(Context { rt, iroh });

    b.with_function(
        "iroh_blob_get_ticket",
        [PTR],
        [PTR],
        ctx,
        iroh_blob_get_ticket,
    )
}

================
File: extism/iroh-extism-host-functions/Cargo.toml
================
[package]
name = "iroh-extism-host-functions"
version = "0.1.0"
edition = "2024"

[dependencies]
anyhow = "1.0.79"
dirs-next = "2.0.0"
extism = "1.0.0"
futures = "0.3.29"
iroh = "0.90"
iroh-blobs = { version = "0.90" }
tokio = { version = "1", features = ["full"] }
tokio-util = { version = "0.7", features = ["codec", "io-util", "io", "time"] }

================
File: extism/plugin/src/lib.rs
================
use extism_pdk::*;

#[host_fn]
extern "ExtismHost" {
    fn iroh_blob_get_ticket(ticket: String) -> Vec<u8>;
}

#[plugin_fn]
pub fn print_hai_and_get_ticket(ticket: String) -> FnResult<Vec<u8>> {
    println!("Hai from a wasm plugin!");
    let v = unsafe { iroh_blob_get_ticket(ticket) }?;
    Ok(v)
}

================
File: extism/plugin/Cargo.toml
================
[package]
name = "plugin"
version = "0.1.0"
edition = "2024"

[lib]
crate-type = ["cdylib"]

[dependencies]
extism-pdk = "1.0.1"

================
File: extism/readme.md
================
# iroh + exsitm

This is an example of running iroh thorugh [exitsm](https://extism.org/) as a set of [host functions](https://extism.org/docs/concepts/host-functions). It's written entirely in rust, but the purpose is to show how one would build an API that any plugin could use to gain access to a plugin-host-provided iroh instance.

## Requirements

You'll need the latest version of the rust toolchain, and the `wasm32-unknown-unknown` target. Install it with:

```
rustup target add wasm32-unknown-unknown
```

## Running the Example

There are three 

1. Build the WASM plugin
2. Get a blob ticket
3. run the host

### 1. Build the WASM plugin

`cd` to `extism/plugin` and run `cargo build --target wasm32-unknown-unknown`. If you get an error, check the requirements section above. This will generate a WASM plugin that actually calls the blob download host function.

### 2. Get a blob ticket

This example needs a `Raw` blob ticket, which you can get from `iroh blob add` on a raw file, or just use this one, which should be hosted on iroh.network:
```
blobabk62aofuwwwu5zb5ocvzj5v3rtqt6siglyuhoxhqtu4fxravvoteajcnb2hi4dthixs65ltmuys2mjomrsxe4bonfzg62bonzsxi53pojvs4lydaac2cyt22erablaraaa5ciqbfiaqj7ya6cbpuaaaaaaaaaaaahjceagucztuhgez4qucv2733xphmgpc2nkgj54od2vuygn6sz4zzxo6ce
```
(it's a text file that says hello)

### 3. Run the host

The host code will actually call the example. `cd` to `./extism/host` and run

```
cargo run <TICKET>
```

pasting in the ticket you'd like to fetch. It'll fetch the bytes & print it out, proving this host can provide iroh to extism plugins!


## Future work

What would be truly neat would be to reverse the direction, and write a plugin that brings iroh to a host. For that we'd need to be able to compile some/all of iroh to WASM, which we're [working on](https://github.com/n0-computer/iroh/issues/1803).

================
File: framed-messages/src/framed.rs
================
use iroh::endpoint::{RecvStream, SendStream};
use tokio_util::codec::{FramedRead, FramedWrite, LengthDelimitedCodec};

const MAX_MESSAGE_SIZE: usize = 1000;

/// This is just a convenience wrapper around a [`FramedRead`] and [`FramedWrite`]
/// with a [`LengthDelimitedCodec`].
///
/// The [`LengthDelimitedCodec`] essentially means we'll prefix messages with a
/// big-endian encoded u32 indicating the length of the following message.
///
/// The [`FramedRead`] and [`FramedWrite`] structs then turn the
/// [`SendStream`] and [`RecvStream`] that implement the individual,
/// bytes-based [`AsyncRead`] and [`AsyncWrite`] implementations into
/// variable-(byte-)sized message [`Stream`]s and [`Sink`]s, also called "Frames"
/// (because you can determine the beginning and end borders on the underlying byte
/// streams).
///
/// [`FramedRead`] does this by implementing a state machine that keeps fetching
/// more and more bytes until it's assembled a full frame, and
/// [`FramedWrite`] does this by implementing a state machine that keeps pushing
/// more and more bytes into the underlying stream until it the whole frame has
/// been written, at which point it accepts more frames to be queued.
///
/// Because these will keep the frames in memory until they're complete, and you
/// probably don't want to an arbitrary amount of memory depending on the bytes
/// that were sent on the wire, you can configure a maximum frame length.
/// We've set it to 1000 bytes in this case ([`MAX_MESSAGE_SIZE`]), but that's
/// (like many other things) configurable in [`LengthDelimitedCodec`].
///
/// [`AsyncRead`]: tokio::io::AsyncRead
/// [`AsyncWrite`]: tokio::io::AsyncWrite
/// [`Stream`]: futures_util::Stream
/// [`Sink`]: futures_util::Sink
pub struct FramedBiStream {
    pub write: FramedWrite<SendStream, LengthDelimitedCodec>,
    pub read: FramedRead<RecvStream, LengthDelimitedCodec>,
}

impl FramedBiStream {
    pub fn new((send, recv): (SendStream, RecvStream)) -> Self {
        let mut codec = LengthDelimitedCodec::builder();
        codec.max_frame_length(MAX_MESSAGE_SIZE);
        Self {
            write: codec.new_write(send),
            read: codec.new_read(recv),
        }
    }
}

================
File: framed-messages/src/lib.rs
================
pub mod framed;

use bytes::BytesMut;
use futures_util::{SinkExt, TryStreamExt};
use iroh::{
    endpoint::Connection,
    protocol::{AcceptError, ProtocolHandler},
};
use serde::{Deserialize, Serialize};

use crate::framed::FramedBiStream;

/// Each protocol is identified by its ALPN string.
///
/// The ALPN, or application-layer protocol negotiation, is exchanged in the connection handshake,
/// and the connection is aborted unless both nodes pass the same bytestring.
pub const ALPN: &[u8] = b"iroh/examples/messages/0";

/// Move is the message type we'll send & receive over the connection.
///
/// It represents all possible "frames" in our framed protocol.
///
/// We use serde and postcard to serialize it into bytes.
/// Then we write them, prefixed with a big-endian encoded `u32` denoting their length, to the stream.
///
/// The idea is that these denote chess moves, but this wouldn't quite suffice.
/// In practice you'd either also need to add promotion or just use SAN (Standard Algebraic Notation)
/// for this, but this is just for demonstration purposes.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Move {
    pub from: (u8, u8),
    pub to: (u8, u8),
}

impl Move {
    pub async fn send(&self, stream: &mut FramedBiStream) -> anyhow::Result<()> {
        let encoded_move = postcard::to_extend(self, BytesMut::new())?.freeze();
        stream.write.send(encoded_move).await?;
        Ok(())
    }

    pub async fn recv(stream: &mut FramedBiStream) -> anyhow::Result<Move> {
        let Some(encoded_move) = stream.read.try_next().await? else {
            anyhow::bail!("unexpected end of stream");
        };
        let mv = postcard::from_bytes(&encoded_move)?;
        Ok(mv)
    }
}

async fn black_moves(stream: &mut FramedBiStream) -> anyhow::Result<()> {
    let mv = Move::recv(stream).await?;
    println!("got move: {mv:?}");

    // Respond with some move
    let mv = Move {
        from: (5, 7),
        to: (5, 6),
    };
    mv.send(stream).await?;

    let mv = Move::recv(stream).await?;
    println!("got move: {mv:?}");

    // And respond with another one
    let mv = Move {
        from: (5, 8),
        to: (5, 7),
    };
    mv.send(stream).await?;

    Ok(())
}

/// This struct implements the receiving side of the protocol via [`ProtocolHandler`].
#[derive(Debug, Clone)]
pub struct ChessProtocol;

impl ProtocolHandler for ChessProtocol {
    /// The `accept` method is called for each incoming connection for our ALPN.
    ///
    /// The returned future runs on a newly spawned tokio task, so it can run as long as
    /// the connection lasts.
    async fn accept(&self, connection: Connection) -> Result<(), AcceptError> {
        // We can get the remote's node id from the connection.
        let node_id = connection.remote_node_id()?;
        println!("accepted connection from {node_id}");

        // Our protocol is a simple request-response protocol, so we expect the
        // connecting peer to open a single bi-directional stream.
        let bi_stream = connection.accept_bi().await?;
        let mut stream = FramedBiStream::new(bi_stream);

        // make some moves
        black_moves(&mut stream)
            .await
            .map_err(anyhow::Error::into_boxed_dyn_error)?;

        // We could keep going, but we'll call `SendStream::finish()` to indicate we're done.
        stream.write.get_mut().finish()?;

        // Wait until the remote closes the connection, which it does once it
        // received the response.
        connection.closed().await;

        Ok(())
    }
}

================
File: framed-messages/src/main.rs
================
// a program that creates two endpoints & sends a ping between them
use iroh::{Endpoint, Watcher, protocol::Router};

use framed_messages::{ALPN as ChessMovesALPN, ChessProtocol, Move, framed::FramedBiStream};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // create the receive side
    let recv_ep = Endpoint::builder().discovery_n0().bind().await?;
    let recv_router = Router::builder(recv_ep)
        .accept(ChessMovesALPN, ChessProtocol)
        .spawn();
    let addr = recv_router.endpoint().node_addr().initialized().await?;

    // create a send side & send a ping
    let send_ep = Endpoint::builder().discovery_n0().bind().await?;
    let conn = send_ep.connect(addr, ChessMovesALPN).await?;
    let bi_stream = conn.open_bi().await?;
    // We use the `FramedBiStream` to provide us message framing
    let mut stream = FramedBiStream::new(bi_stream);

    // make some moves
    white_moves(&mut stream).await?;

    // We're done with the connection:
    conn.close(0u32.into(), b"bye!");

    // Close gracefully:
    send_ep.close().await;
    recv_router.shutdown().await?;

    Ok(())
}

async fn white_moves(stream: &mut FramedBiStream) -> anyhow::Result<()> {
    let mv = Move {
        from: (4, 2),
        to: (4, 4),
    };
    mv.send(stream).await?;

    let mv = Move::recv(stream).await?;
    println!("received move: {mv:?}");

    let mv = Move {
        from: (3, 2),
        to: (3, 3),
    };
    mv.send(stream).await?;

    let mv = Move::recv(stream).await?;
    println!("received move: {mv:?}");

    Ok(())
}

================
File: framed-messages/Cargo.toml
================
[package]
name = "framed-messages"
version = "0.1.0"
edition = "2024"

[dependencies]
anyhow = "1.0.98"
bytes = "1.10.1"
futures-util = { version = "0.3.31", features = ["sink"] }
iroh = "0.90.0"
iroh-metrics = "0.35.0"
n0-snafu = "0.2.1"
n0-watcher = "0.2.0"
postcard = "1.1.2"
serde = { version = "1.0.219", features = ["derive"] }
tokio = { version = "1.46.1", features = ["full"] }
tokio-util = { version = "0.7.15", features = ["codec"] }

================
File: framed-messages/README.md
================
# Message Framing with iroh

If you're implementing your own protocol on iroh connections, you might run into the issue that the atomic unit of data you can send on a stream is a single byte.
So if you want to send multiple "messages" on the same stream, you need to tell the other side where these messages begin and end.
This is process is called "framing" in networking terms.

In this example we're sending chess moves back and forth on the same bi-directional stream.
To do this, we use the `codec` feature from the `tokio-util` crate.
It works like this:
- The `SendStream` and `RecvStream` that we get from `iroh::Connection::open_bi` implement the `AsyncWrite` and `AsyncWrite` traits, respectively.
  These allow us to send and receive byte streams without framing.
- We wrap these streams using `tokio_util::codec::FramedRead` and `FramedWrite` using a `LengthDelimitedCodec`.
  These wrappers take a codec and an `AsyncRead`/`AsyncWrite` and turn them into a `futures_util::Stream`/`futures_util::Sink`, respectively.
- `Stream` and `Sink` work on messages, not byte streams, so now we can send *framed* "chunks" of `bytes::Bytes` on our streams.
  This works by using the `LengthDelimitedCodec` for framing, it essentially prefixes our messages with a big-endian encoded u32 representing the length of the message that follows it.
  This way the receiving end always knows where a message begins and ends.
- Finally we use `postcard` and `serde` to serialize and deserialize our `Move` struct into and from bytes.

================
File: frosty/src/main.rs
================
use clap::Parser;
use frost_ed25519::{
    self as frost, Ciphersuite, Ed25519ScalarField, Ed25519Sha512, Field, Group, Identifier,
    SigningPackage,
    keys::{IdentifierList, KeyPackage, PublicKeyPackage, SecretShare},
};
use futures::StreamExt;
use iroh::{
    PublicKey, SecretKey, Watcher,
    discovery::{dns::DnsDiscovery, pkarr::PkarrPublisher},
    endpoint::{RecvStream, SendStream},
};
use rand::thread_rng;
use sha2::{Digest, Sha512};
use ssh_key::LineEnding;
use std::{
    collections::BTreeMap,
    fs,
    path::{Path, PathBuf},
    str::FromStr,
};
use tokio::io::{AsyncReadExt, AsyncWrite, AsyncWriteExt};
use tracing::{error, info, warn};

const COSIGN_ALPN: &[u8] = b"FROST_COSIGN";

#[derive(Debug, clap::Parser)]
struct Args {
    #[clap(subcommand)]
    cmd: Command,
}

#[derive(Debug, clap::Parser)]
enum Command {
    Split(SplitArgs),
    ReSplit(ReSplitArgs),
    SignLocal(SignLocalArgs),
    Sign(SignArgs),
    Cosign(CosignArgs),
}

#[derive(Debug, clap::Parser)]
struct SplitArgs {
    /// Key to split
    #[clap(long)]
    key: PathBuf,
    #[clap(long, default_value_t = 2, help = "Minimum number of signers")]
    min_signers: u16,
    #[clap(long, default_value_t = 3, help = "Maximum number of signers")]
    max_signers: u16,
    #[clap(long, help = "Directory to store the key shares")]
    target: PathBuf,
}

#[derive(Debug, clap::Parser)]
struct SignLocalArgs {
    directories: Vec<String>,
    #[clap(long)]
    message: String,
    #[clap(long)]
    key: PublicKey,
}

#[derive(Debug, clap::Parser)]
struct ReSplitArgs {
    directories: Vec<String>,
    #[clap(long)]
    key: PublicKey,
    #[clap(long, default_value_t = 2, help = "Minimum number of signers")]
    min_signers: u16,
    #[clap(long, default_value_t = 3, help = "Maximum number of signers")]
    max_signers: u16,
    #[clap(long, help = "Directory to store the key shares")]
    target: PathBuf,
}

#[derive(Debug, clap::Parser)]
struct SignArgs {
    cosigners: Vec<PublicKey>,
    #[clap(long)]
    message: String,
    #[clap(long)]
    key: PublicKey,
    /// Optional path to the directory where the fragments are stored
    /// If not provided, the current directory is used
    #[clap(long)]
    data_path: Option<PathBuf>,
}

#[derive(Debug, clap::Parser)]
struct CosignArgs {
    /// Optional path to the directory where the fragments are stored
    /// If not provided, the current directory is used
    #[clap(long)]
    data_path: Option<PathBuf>,
}

fn try_from_openssh<T: AsRef<[u8]>>(data: T) -> anyhow::Result<iroh::SecretKey> {
    let ser_key = ssh_key::private::PrivateKey::from_openssh(data)?;
    match ser_key.key_data() {
        ssh_key::private::KeypairData::Ed25519(kp) => {
            Ok(SecretKey::from_bytes(&kp.private.to_bytes()))
        }
        _ => anyhow::bail!("invalid key format"),
    }
}

fn to_openssh(key: &SecretKey) -> ssh_key::Result<zeroize::Zeroizing<String>> {
    let ckey = ssh_key::private::Ed25519Keypair {
        public: key.secret().verifying_key().into(),
        private: key.secret().clone().into(),
    };
    ssh_key::private::PrivateKey::from(ckey).to_openssh(LineEnding::default())
}

fn split(args: SplitArgs) -> anyhow::Result<()> {
    if args.max_signers < args.min_signers {
        anyhow::bail!("max-signers must be greater than or equal to min-signers");
    }
    let max_signers = args.max_signers;
    let min_signers = args.min_signers;
    let key = fs::read_to_string(&args.key)?;
    let iroh_key = try_from_openssh(key)?;
    let key_bytes = iroh_key.to_bytes();
    let scalar = ed25519_secret_key_to_scalar(&key_bytes);
    let key = frost::SigningKey::from_scalar(scalar)?;
    println!(
        "Splitting key {} into {} parts",
        iroh_key.public(),
        max_signers
    );
    let (parts, pubkey) = frost::keys::split(
        &key,
        max_signers,
        min_signers,
        IdentifierList::Default,
        &mut thread_rng(),
    )?;
    let pubkey_bytes = pubkey.serialize()?;
    for (i, secret_share) in parts.values().enumerate() {
        let n = i + 1;
        let path: PathBuf = args.target.join(n.to_string());
        println!("Storing part {} in directory {}", n, path.display());
        fs::create_dir_all(&path)?;
        let pubkey_path = path.join(format!("{}.pub", iroh_key.public()));
        fs::write(pubkey_path, &pubkey_bytes)?;
        let key_path = path.join(format!("{}.secret", iroh_key.public()));
        let secret_share_bytes = secret_share.serialize()?;
        fs::write(key_path, secret_share_bytes)?;
    }
    Ok(())
}

fn resplit(args: ReSplitArgs) -> anyhow::Result<()> {
    if args.directories.len() < 2 {
        anyhow::bail!("At least two directories are required");
    }
    if args.max_signers < args.min_signers {
        anyhow::bail!("max-signers must be greater than or equal to min-signers");
    }
    println!("Reconstructing key from {:?}", args.directories);
    let mut parts = Vec::new();
    let key = args.key;
    for part in args.directories.iter() {
        let secret_share_path = PathBuf::from(part).join(format!("{key}.secret"));
        let secret_share_bytes = fs::read(&secret_share_path)?;
        let secret_share = SecretShare::deserialize(&secret_share_bytes)?;
        let key_package = frost::keys::KeyPackage::try_from(secret_share)?;
        let public_key_package_path = PathBuf::from(part).join(format!("{key}.pub"));
        let public_key_package_bytes = fs::read(&public_key_package_path)?;
        let public_key_package = PublicKeyPackage::deserialize(&public_key_package_bytes)?;
        parts.push((key_package, public_key_package));
    }
    let key_packages = parts
        .iter()
        .map(|(key_package, _)| key_package.clone())
        .collect::<Vec<_>>();
    let secret = frost::keys::reconstruct(key_packages.as_slice())?;
    let (parts, pubkey) = frost::keys::split(
        &secret,
        args.max_signers,
        args.min_signers,
        IdentifierList::Default,
        &mut thread_rng(),
    )?;
    let public_key_package_bytes = pubkey.serialize()?;
    println!("Re-splitting key into {} parts", args.max_signers);
    for (i, (_, secret_share)) in parts.iter().enumerate() {
        let n = i + 1;
        let secret_share_bytes = secret_share.serialize()?;
        let dir = args.target.join(format!("{n}"));
        println!("Storing part {} in directory {}", n, dir.display());
        fs::create_dir_all(&dir)?;
        let secret_share_path = dir.join(format!("{}.secret", args.key));
        fs::write(secret_share_path, secret_share_bytes)?;
        let public_key_package_path = dir.join(format!("{}.pub", args.key));
        fs::write(public_key_package_path, public_key_package_bytes.clone())?;
    }
    Ok(())
}

fn sign_local(args: SignLocalArgs) -> anyhow::Result<()> {
    let mut parts = Vec::new();
    let mut paths = Vec::new();
    let key = args.key;
    for part in args.directories.iter() {
        let secret_share_path = PathBuf::from(part).join(format!("{key}.secret"));
        let secret_share_bytes = fs::read(&secret_share_path)?;
        paths.push(secret_share_path);
        let secret_share = SecretShare::deserialize(&secret_share_bytes)?;
        let key_package = frost::keys::KeyPackage::try_from(secret_share)?;
        parts.push(key_package);
    }
    let secret = frost::keys::reconstruct(parts.as_slice())?;
    println!("Reconstructed a signing key from {paths:?}");
    let msg = args.message.as_bytes();
    let signature = secret.sign(rand::thread_rng(), msg);
    let signature_bytes = signature.serialize()?;
    println!("Signature: {}", hex::encode(&signature_bytes));
    let iroh_signature = iroh_base::Signature::from_slice(&signature_bytes)?;
    let res = key.verify(msg, &iroh_signature);
    if res.is_err() {
        println!("Verification failed: {res:?}");
        res?;
    }
    Ok(())
}

fn ed25519_secret_key_to_scalar(secret_key: &[u8; 32]) -> <Ed25519ScalarField as Field>::Scalar {
    // Step 1: Hash the secret key using SHA-512
    let mut hasher = Sha512::new();
    hasher.update(secret_key);
    let hash = hasher.finalize();

    // Step 2: Take the first 32 bytes of the hash and apply bit manipulations
    let mut scalar_bytes = [0u8; 32];
    scalar_bytes.copy_from_slice(&hash[..32]);

    // Step 3: Perform bitwise manipulations to ensure it's a valid scalar
    scalar_bytes[0] &= 248; // Clear the lowest 3 bits
    scalar_bytes[31] &= 127; // Clear the highest bit
    scalar_bytes[31] |= 64; // Set the second highest bit

    // Step 4: Create the Scalar from the modified bytes
    <Ed25519ScalarField as Field>::Scalar::from_bytes_mod_order(scalar_bytes)
}

async fn handle_cosign_request(
    incoming: iroh::endpoint::Incoming,
    data_path: PathBuf,
) -> anyhow::Result<()> {
    // we don't need to check the ALPN, since we only accept connections with the correct ALPN
    let connection = incoming.await?;
    let remote_node_id = connection.remote_node_id()?;
    info!("Incoming connection from {}", remote_node_id,);
    let (mut send, mut recv) = connection.accept_bi().await?;
    let key_bytes = read_exact_bytes(&mut recv).await?;
    let key = PublicKey::from_bytes(&key_bytes)?;
    info!("Received request to co-sign for key {}", key);
    let secret_share_path = data_path.join(format!("{key}.secret"));
    let secret_share_bytes = tokio::fs::read(&secret_share_path).await?;
    let secret_share = SecretShare::deserialize(&secret_share_bytes)?;
    let key_package = KeyPackage::try_from(secret_share)?;
    info!("Got fragment, creating commitment");
    let (nonces, commitments) =
        frost::round1::commit(key_package.signing_share(), &mut thread_rng());
    info!("Sending identifier");
    send.write_all(&key_package.identifier().serialize())
        .await?;
    info!("Sending commitment");
    write_lp(&mut send, &commitments.serialize()?).await?;
    info!("Waiting for signing package");
    let signing_package = SigningPackage::deserialize(&read_lp(&mut recv).await?)?;
    info!("Received signing package, creating signature share");
    let signature_share = frost::round2::sign(&signing_package, &nonces, &key_package)?;
    info!("Sending signature share");
    send.write_all(&signature_share.serialize()).await?;
    info!("Finished handling cosign request");
    // wait for the connection to close.
    // if we don't do this, we might lose the last message in transit
    // See https://www.iroh.computer/blog/closing-a-quic-connection for details
    connection.closed().await;
    Ok(())
}

async fn send_cosign_request_round1(
    endpoint: &iroh::Endpoint,
    cosigner: &PublicKey,
    key: &PublicKey,
) -> anyhow::Result<(
    SendStream,
    RecvStream,
    Identifier,
    frost::round1::SigningCommitments,
)> {
    let connection = endpoint.connect(*cosigner, COSIGN_ALPN).await?;
    let (mut send, mut recv) = connection.open_bi().await?;
    info!("Sending cosign request for key {} to {}", key, cosigner);
    send.write_all(key.as_bytes()).await?;
    let identifier_bytes: <<<Ed25519Sha512 as Ciphersuite>::Group as Group>::Field as Field>::Serialization = read_exact_bytes(&mut recv).await?;
    let identifier = Identifier::deserialize(&identifier_bytes)?;
    let commitments_bytes = read_lp(&mut recv).await?;
    let commitments = frost::round1::SigningCommitments::deserialize(&commitments_bytes)?;
    info!("Received commitments");
    Ok((send, recv, identifier, commitments))
}

async fn sign(args: SignArgs) -> anyhow::Result<()> {
    let data_path = args.data_path.unwrap_or_else(|| PathBuf::from("."));
    let secret_key = get_or_create_key(&data_path.join("keypair"))?;
    let key = args.key;
    let secret_share_path = data_path.join(format!("{key}.secret"));
    info!("Reading secret share from {}", secret_share_path.display());
    let secret_share_bytes = fs::read(&secret_share_path)?;
    let secret_share = SecretShare::deserialize(&secret_share_bytes)?;
    let key_package = KeyPackage::try_from(secret_share)?;
    if args.cosigners.len() + 1 < (*key_package.min_signers() as usize) {
        anyhow::bail!(
            "At least {} cosigners are required",
            key_package.min_signers() - 1
        );
    }
    let public_key_package_path = data_path.join(format!("{key}.pub"));
    info!(
        "Reading public key package from {}",
        public_key_package_path.display()
    );
    let public_key_package = PublicKeyPackage::deserialize(&fs::read(&public_key_package_path)?)?;
    info!("Creating local commitment");
    let (nonce, commitments) =
        frost::round1::commit(key_package.signing_share(), &mut thread_rng());

    let min_cosigners = (key_package.min_signers() - 1) as usize;
    info!("{} co-signers required", min_cosigners);
    let discovery = DnsDiscovery::n0_dns();
    let endpoint = iroh::endpoint::Endpoint::builder()
        .secret_key(secret_key)
        .discovery(discovery)
        .bind()
        .await?;
    // get at least min_cosigners cosigners
    // for each cosigner, we get send and recv streams, identifier and commitments
    info!("Get commitment from {} cosigners", min_cosigners);
    let cosigners = futures::stream::iter(args.cosigners.iter())
        .map(|cosigner| send_cosign_request_round1(&endpoint, cosigner, &args.key))
        .buffer_unordered(10)
        .filter_map(|res| async {
            res.inspect_err(|e| warn!("Error sending cosign request: {:?}", e))
                .ok()
        })
        .take(min_cosigners)
        .collect::<Vec<_>>()
        .await;
    let mut commitments_map = BTreeMap::new();
    for (_, _, identifier, commitments) in cosigners.iter() {
        commitments_map.insert(*identifier, *commitments);
    }
    let local_identifier = *key_package.identifier();
    commitments_map.insert(local_identifier, commitments);
    let signing_package = frost::SigningPackage::new(commitments_map, args.message.as_bytes());
    let signing_package_bytes = signing_package.serialize()?;
    let mut signature_shares = BTreeMap::new();
    info!("Creating local signature share");
    let local_signature_share = frost::round2::sign(&signing_package, &nonce, &key_package)?;
    signature_shares.insert(local_identifier, local_signature_share);
    for (mut send, mut recv, identifier, _) in cosigners {
        write_lp(&mut send, &signing_package_bytes).await?;
        let signature_share_bytes: <<<Ed25519Sha512 as Ciphersuite>::Group as Group>::Field as Field>::Serialization = read_exact_bytes(&mut recv).await?;
        let signature_share = frost::round2::SignatureShare::deserialize(&signature_share_bytes)?;
        signature_shares.insert(identifier, signature_share);
    }
    info!("got {} signature shares", signature_shares.len());
    let signature = frost::aggregate(&signing_package, &signature_shares, &public_key_package)?;
    let bytes = signature.serialize()?;
    let iroh_signature = iroh_base::Signature::from_slice(&bytes)?;
    if let Err(cause) = key.verify(args.message.as_bytes(), &iroh_signature) {
        error!("Verification failed: {:?}", cause);
    }
    println!("Signature: {}", hex::encode(bytes));
    endpoint.close().await;
    Ok(())
}

async fn cosign_daemon(args: CosignArgs) -> anyhow::Result<()> {
    let data_path = args.data_path.unwrap_or_else(|| PathBuf::from("."));
    let secret_key = get_or_create_key(&data_path.join("keypair"))?;
    let mut keys = Vec::new();
    for entry in fs::read_dir(&data_path)? {
        let entry = entry?;
        let path = entry.path();
        if path
            .extension()
            .map(|ext| ext == "secret")
            .unwrap_or_default()
        {
            if let Some(stem) = path.file_stem() {
                if let Some(text) = stem.to_str() {
                    let key = iroh::PublicKey::from_str(text)?;
                    let secret_share_bytes = fs::read(&path)?;
                    let secret_share = SecretShare::deserialize(&secret_share_bytes)?;
                    let key_package = frost::keys::KeyPackage::try_from(secret_share)?;
                    keys.push((key, key_package));
                }
            }
        }
    }
    if !keys.is_empty() {
        println!("Can cosign for following keys");
        for (key, key_package) in keys.iter() {
            println!("- {} (min {} signers)", key, key_package.min_signers());
        }
    }
    let discovery = PkarrPublisher::n0_dns().build(secret_key.clone());
    let endpoint = iroh::endpoint::Endpoint::builder()
        .alpns(vec![COSIGN_ALPN.to_vec()])
        .secret_key(secret_key)
        .discovery(discovery)
        .bind()
        .await?;
    let addr = endpoint.node_addr().initialized().await?;
    println!("\nListening on {}", addr.node_id);
    while let Some(incoming) = endpoint.accept().await {
        let data_path = data_path.clone();
        tokio::task::spawn(async {
            if let Err(cause) = handle_cosign_request(incoming, data_path).await {
                tracing::error!("Error handling cosign request: {:?}", cause);
            }
        });
    }
    Ok(())
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt::init();
    let args = Args::parse();
    match args.cmd {
        Command::Split(args) => split(args)?,
        Command::ReSplit(args) => resplit(args)?,
        Command::SignLocal(args) => sign_local(args)?,
        Command::Cosign(args) => cosign_daemon(args).await?,
        Command::Sign(args) => sign(args).await?,
    }
    Ok(())
}

fn get_or_create_key(path: &Path) -> anyhow::Result<SecretKey> {
    if path.exists() {
        let key_bytes = std::fs::read(path)?;
        Ok(try_from_openssh(key_bytes.as_slice())?)
    } else {
        let key = SecretKey::generate(rand::thread_rng());
        let key_bytes = to_openssh(&key)?;
        std::fs::write(path, &key_bytes)?;
        Ok(key)
    }
}

async fn read_exact_bytes<R: AsyncReadExt + Unpin, const N: usize>(
    reader: &mut R,
) -> anyhow::Result<[u8; N]> {
    let mut buf = [0u8; N];
    reader.read_exact(&mut buf).await?;
    Ok(buf)
}

async fn write_lp<W: AsyncWrite + Unpin>(writer: &mut W, data: &[u8]) -> anyhow::Result<()> {
    let len = data.len() as u32;
    writer.write_all(&len.to_be_bytes()).await?;
    writer.write_all(data).await?;
    Ok(())
}

async fn read_lp<R: tokio::io::AsyncRead + Unpin>(reader: &mut R) -> anyhow::Result<Vec<u8>> {
    let mut len_bytes = [0u8; 4];
    reader.read_exact(&mut len_bytes).await?;
    let len = u32::from_be_bytes(len_bytes) as usize;
    let mut data = vec![0u8; len];
    reader.read_exact(&mut data).await?;
    Ok(data)
}

/// Example copied from the frost docs
#[allow(dead_code)]
#[allow(clippy::unnecessary_cast)]
fn example() -> anyhow::Result<()> {
    let mut rng = thread_rng();
    let max_signers = 5;
    let min_signers = 3;
    let (shares, pubkey_package) = frost::keys::generate_with_dealer(
        max_signers,
        min_signers,
        frost::keys::IdentifierList::Default,
        &mut rng,
    )?;

    // Verifies the secret shares from the dealer and store them in a BTreeMap.
    // In practice, the KeyPackages must be sent to its respective participants
    // through a confidential and authenticated channel.
    let mut key_packages: BTreeMap<_, _> = BTreeMap::new();

    for (identifier, secret_share) in shares {
        let key_package = frost::keys::KeyPackage::try_from(secret_share)?;
        key_packages.insert(identifier, key_package);
    }
    println!("Key packages generated successfully!");
    for (k, v) in key_packages.iter() {
        println!("Key package for participant {k:?}: {v:?}");
    }

    let mut nonces_map = BTreeMap::new();
    let mut commitments_map = BTreeMap::new();

    ////////////////////////////////////////////////////////////////////////////
    // Round 1: generating nonces and signing commitments for each participant
    ////////////////////////////////////////////////////////////////////////////

    // In practice, each iteration of this loop will be executed by its respective participant.
    for participant_index in 1..(min_signers as u16 + 1) {
        let participant_identifier = participant_index.try_into().expect("should be nonzero");
        let key_package = &key_packages[&participant_identifier];
        // Generate one (1) nonce and one SigningCommitments instance for each
        // participant, up to _threshold_.
        let (nonces, commitments) = frost::round1::commit(key_package.signing_share(), &mut rng);
        // In practice, the nonces must be kept by the participant to use in the
        // next round, while the commitment must be sent to the coordinator
        // (or to every other participant if there is no coordinator) using
        // an authenticated channel.
        nonces_map.insert(participant_identifier, nonces);
        commitments_map.insert(participant_identifier, commitments);
    }

    // This is what the signature aggregator / coordinator needs to do:
    // - decide what message to sign
    // - take one (unused) commitment per signing participant
    let mut signature_shares = BTreeMap::new();
    let message = "message to sign".as_bytes();
    let signing_package = frost::SigningPackage::new(commitments_map, message);

    ////////////////////////////////////////////////////////////////////////////
    // Round 2: each participant generates their signature share
    ////////////////////////////////////////////////////////////////////////////

    // In practice, each iteration of this loop will be executed by its respective participant.
    for participant_identifier in nonces_map.keys() {
        let key_package = &key_packages[participant_identifier];

        let nonces = &nonces_map[participant_identifier];

        // Each participant generates their signature share.
        let signature_share = frost::round2::sign(&signing_package, nonces, key_package)?;

        // In practice, the signature share must be sent to the Coordinator
        // using an authenticated channel.
        signature_shares.insert(*participant_identifier, signature_share);
    }

    ////////////////////////////////////////////////////////////////////////////
    // Aggregation: collects the signing shares from all participants,
    // generates the final signature.
    ////////////////////////////////////////////////////////////////////////////

    // Aggregate (also verifies the signature shares)
    let group_signature = frost::aggregate(&signing_package, &signature_shares, &pubkey_package)?;

    // Check that the threshold signature can be verified by the group public
    // key (the verification key).
    let is_signature_valid = pubkey_package
        .verifying_key()
        .verify(message, &group_signature)
        .is_ok();
    assert!(is_signature_valid);
    Ok(())
}

================
File: frosty/Cargo.toml
================
[package]
name = "frosty"
version = "0.1.0"
edition = "2024"

[dependencies]
anyhow = "1.0.89"
clap = { version = "4.5.18", features = ["derive"] }
frost-ed25519 = "2.0.0"
futures = "0.3.30"
hex = "0.4.3"
iroh = "0.90"
iroh-base = "0.90"
pkarr = "2.2.0"
rand = "0.8.5"
sha2 = "0.10.8"
ssh-key = { version = "0.6", features = ["ed25519", "ecdsa"] }
tokio = { version = "1.40.0", features = ["full"] }
tracing = "0.1.40"
tracing-subscriber = "0.3.18"
zeroize = { version = "1.5" }

================
File: frosty/README.md
================
# Experiment with FROST signatures for iroh, pkarr or nostr ed keypairs

This is using the [frost-ed25519](https://docs.rs/frost-ed25519/latest/frost_ed25519/) crate, which implements [FROST: Flexible Round-Optimized
Schnorr Threshold Signatures](https://eprint.iacr.org/2020/852.pdf)

## Splitting a keypair

Split the keypair in ~/.iroh/keypair into subdirectories a/1, a/2, a/3

```
> cargo run split --key ~/.iroh/keypair --target a
```

Minimum number of parts is 3. Default threshold is n-1.

The original keypair is kept in place. In a real application you would delete
the keypair.

## Local signing using the fragments

```
> cargo run sign a/1 a/3 --key 25mzjgjlrcrma7wkm4l3fjv2afcs53cvmmyw3v2uwwt2dczsinaa --message test
Reconstructed a signing key from ["a/25mzjgjlrcrma7wkm4l3fjv2afcs53cvmmyw3v2uwwt2dczsinaa.secret", "c/25mzjgjlrcrma7wkm4l3fjv2afcs53cvmmyw3v2uwwt2dczsinaa.secret"]
Signature: daec0537cd6f080cce1ae7150684ac3147e576c9bde9a74d27e914bcfa834cef2d204ff9295379784fcca3eaa95e4b196b4fb8b60ec316840b5e649844db880e
```

## Co-signing daemon

Start with one of the directories created by split. We created splits a, b and
c in the previous example, so let's use a.

```
> cargo run cosign --data-path a

Can cosign for following keys
- 25mzjgjlrcrma7wkm4l3fjv2afcs53cvmmyw3v2uwwt2dczsinaa (min 2 signers)

Listening on 2wgtsap6bsur5ruzb6pxdindy6j2n4e5zyq34tz7n2kjmngter2a
```

## Signing

Signing assumes that you have 1 fragment local, and need a number of remote
co-signers. You must provide the key you want to sign for and the iroh node id
for all possible co-signers.

Each co-signer must have a different fragment, and the local fragment should also
be different to all the fragments the co-signers are using.

In this case we are using b locally and node 2wgtsap6bsur5ruzb6pxdindy6j2n4e5zyq34tz7n2kjmngter2a
is using a remotely.

In a real usage you would not have the three fragments on the same machine, since
that defeats the purpose of the scheme.

```
> cargo run sign --message test --data-path b --key 25mzjgjlrcrma7wkm4l3fjv2afcs53cvmmyw3v2uwwt2dczsinaa 2wgtsap6bsur5ruzb6pxdindy6j2n4e5zyq34tz7n2kjmngter2a

Signature: 8cfae38266ee55c274d865b352b94d19e701def117fbcafd4eefccde8eefa5a8382d43275bafe2da6c39e07fdd2b88a12a43c8b12126d17e3a7c2bf14590400f
```

================
File: iroh-automerge/src/main.rs
================
use anyhow::Result;
use automerge::{Automerge, ReadDoc, transaction::Transactable};
use clap::Parser;
use iroh::{Endpoint, protocol::Router};
use protocol::IrohAutomergeProtocol;
use tokio::sync::mpsc;

mod protocol;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    #[clap(long)]
    remote_id: Option<iroh::NodeId>,
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt::init();

    let opts = Cli::parse();

    // We set up a channel so we can subscribe to sync events from the automerge protocol
    let (sync_sender, mut sync_finished) = mpsc::channel(10);
    let automerge = IrohAutomergeProtocol::new(Automerge::new(), sync_sender);
    let endpoint = Endpoint::builder().discovery_n0().bind().await?;
    let iroh = Router::builder(endpoint)
        .accept(IrohAutomergeProtocol::ALPN, automerge.clone())
        .spawn();

    let node_id = iroh.endpoint().node_id();

    println!("Running\nNode Id: {node_id}",);

    // we distinguish the roles in protocol based on if the --remote-id CLI argument is present
    if let Some(remote_id) = opts.remote_id {
        // on the provider side:

        // Put some data in the document to sync
        let mut doc = automerge.fork_doc().await;
        let mut t = doc.transaction();
        for i in 0..5 {
            t.put(automerge::ROOT, format!("key-{i}"), format!("value-{i}"))?;
        }
        t.commit();
        automerge.merge_doc(&mut doc).await?;

        // connect to the other node
        let node_addr = iroh::NodeAddr::new(remote_id);
        let conn = iroh
            .endpoint()
            .connect(node_addr, IrohAutomergeProtocol::ALPN)
            .await?;

        // initiate a sync session over an iroh-net direct connection
        automerge.initiate_sync(conn).await?;
    } else {
        // on the receiver side:

        // wait for the first sync to finish
        let doc = sync_finished.recv().await.unwrap();
        println!("State");
        let keys: Vec<_> = doc.keys(automerge::ROOT).collect();
        for key in keys {
            let (value, _) = doc.get(automerge::ROOT, &key)?.unwrap();
            println!("{key} => {value}");
        }
    }

    // finally shut down
    iroh.shutdown().await?;

    Ok(())
}

================
File: iroh-automerge/src/protocol.rs
================
use std::sync::Arc;

use anyhow::Result;
use automerge::{
    Automerge,
    sync::{self, SyncDoc},
};
use iroh::{
    endpoint::{Connection, RecvStream, SendStream},
    protocol::{AcceptError, ProtocolHandler},
};
use tokio::sync::{Mutex, mpsc};

#[derive(Debug, Clone)]
pub struct IrohAutomergeProtocol {
    inner: Arc<Mutex<Automerge>>,
    sync_finished: mpsc::Sender<Automerge>,
}

impl IrohAutomergeProtocol {
    pub const ALPN: &'static [u8] = b"iroh/automerge/2";

    pub fn new(doc: Automerge, sync_finished: mpsc::Sender<Automerge>) -> Arc<Self> {
        Arc::new(Self {
            inner: Arc::new(Mutex::new(doc)),
            sync_finished,
        })
    }

    pub async fn fork_doc(&self) -> Automerge {
        let automerge = self.inner.lock().await;
        automerge.fork()
    }

    pub async fn merge_doc(&self, doc: &mut Automerge) -> Result<()> {
        let mut automerge = self.inner.lock().await;
        automerge.merge(doc)?;
        Ok(())
    }

    async fn send_msg(msg: Option<automerge::sync::Message>, send: &mut SendStream) -> Result<()> {
        if let Some(msg) = msg {
            let encoded = msg.encode();
            // prefix with the length
            send.write_all(&(encoded.len() as u64).to_le_bytes())
                .await?;
            // write the message itself
            send.write_all(&encoded).await?;
        } else {
            // write length == 0 to indicate no message
            // (actual message lengths will always be > 0)
            send.write_all(&0u64.to_le_bytes()).await?;
        }
        Ok(())
    }

    async fn recv_msg(recv: &mut RecvStream) -> Result<Option<automerge::sync::Message>> {
        // read the length prefix
        let mut incoming_len = [0u8; 8];
        recv.read_exact(&mut incoming_len).await?;
        let len = u64::from_le_bytes(incoming_len);

        if len == 0 {
            // zero length indicates no meaningful message this round
            return Ok(None);
        }

        // read the message itself
        let mut buffer = vec![0u8; len as usize];
        recv.read_exact(&mut buffer).await?;
        let msg = automerge::sync::Message::decode(&buffer)?;

        Ok(Some(msg))
    }

    pub async fn initiate_sync(self: Arc<Self>, conn: Connection) -> Result<()> {
        let (mut send, mut recv) = conn.open_bi().await?;

        let mut doc = self.fork_doc().await;
        let mut sync_state = sync::State::new();

        loop {
            let our_msg = doc.generate_sync_message(&mut sync_state);
            let is_local_done = our_msg.is_none();
            Self::send_msg(our_msg, &mut send).await?;

            let their_msg = Self::recv_msg(&mut recv).await?;
            let is_remote_done = their_msg.is_none();

            if let Some(sync_msg) = their_msg {
                doc.receive_sync_message(&mut sync_state, sync_msg)?;
                self.merge_doc(&mut doc).await?;
            }

            if is_remote_done && is_local_done {
                // both sides are done
                break;
            }
        }

        // we're the last to receive data, so we close
        conn.close(0u32.into(), b"thanks, bye!");

        Ok(())
    }

    pub async fn respond_sync(&self, conn: Connection) -> Result<()> {
        let (mut send, mut recv) = conn.accept_bi().await?;

        let mut doc = self.fork_doc().await;
        let mut sync_state = sync::State::new();

        loop {
            let their_msg = Self::recv_msg(&mut recv).await?;
            let is_remote_done = their_msg.is_none();

            // process incoming message
            if let Some(sync_msg) = their_msg {
                doc.receive_sync_message(&mut sync_state, sync_msg)?;
                self.merge_doc(&mut doc).await?;
            }

            let our_msg = doc.generate_sync_message(&mut sync_state);
            let is_local_done = our_msg.is_none();
            Self::send_msg(our_msg, &mut send).await?;

            if is_remote_done && is_local_done {
                // both sides are done
                break;
            }
        }

        // We were the last to send, so we wait on the other side to close
        conn.closed().await;

        Ok(())
    }
}

impl ProtocolHandler for IrohAutomergeProtocol {
    async fn accept(&self, conn: Connection) -> Result<(), iroh::protocol::AcceptError> {
        self.respond_sync(conn)
            .await
            .map_err(anyhow::Error::into_boxed_dyn_error)?;

        self.sync_finished
            .send(self.fork_doc().await)
            .await
            .map_err(AcceptError::from_err)?;

        Ok(())
    }
}

================
File: iroh-automerge/.gitignore
================
/target

================
File: iroh-automerge/Cargo.toml
================
[package]
name = "iroh-automerge"
version = "0.1.0"
edition = "2024"

[dependencies]
anyhow = "1.0.80"
automerge = "0.6.1"
clap = { version = "4.5.1", features = ["derive"] }
iroh = "0.90"
postcard = "1.0.8"
serde = { version = "1.0.197", features = ["derive"] }
tokio = { version = "1.36.0", features = ["full"] }
tracing-subscriber = { version = "0.3.18", features = ["env-filter"] }

================
File: iroh-automerge/README.md
================
# iroh-automerge

> Integration of iroh with [automerge](https://automerge.org).

## What is automerge?

Automerge is a Conflict-Free Replicated Data Type (CRDT).
It represents JSON-like data that can be efficiently synchronized between machines without needing
a single source of truth, unlike traditional databases.
This enables machine to simply gossip updates and data with each other, eventually converging to the same state on every replica.

## What does this example do?

This example highlights how to integrate [automerge's sync protocol] with [iroh's peer-to-peer connectivity].

To run this example, please open a terminal, clone the examples repository using `git clone https://github.com/n0-computer/iroh-examples`
and enter the `iroh-automerge` directory using `cd iroh-automerge`.

First, we create one node that listens for sync requests using iroh's connections:

```sh
# First Terminal
> cargo run
Running
Node Id: lkpz2uw6jf7qahl7oo6qc46qad5ysszhtdzqyotkb3pwtd7sv3va
```

In iroh, nodes are neither identified by domain name (like websites in the internet), nor are they identified by IP addresses.
Instead, nodes are identified by cryptographic public keys, such as the one printed using the `cargo run` command above.

You can exchange this public key with anyone to establish a secure, encrypted connection anywhere.
In most cases this connection is even automatically upgraded to a direct peer-to-peer connection.

We make sure to copy this public key, so we can talk to this node from somewhere else.
We also open another terminal, while keeping the original one open, so this node keeps running.

Now, let's start another node in the second terminal that will connect to the first node:

```sh
# Second Terminal
> cargo run -- --remote-id lkpz2uw6jf7qahl7oo6qc46qad5ysszhtdzqyotkb3pwtd7sv3va
Running
Node Id: gcq5e7mcsvwgtxfvbu7w7rkikxhfudbqt5yvl34f47qlmsyuy7wa
>
```

This will connect the two nodes, have them exchange data and finish running within a couple of seconds.

Coming back to the first terminal, we'll see that the receiving end got all data:

```sh
# Back on the first Terminal
State
key-0 => "value-0"
key-1 => "value-1"
key-2 => "value-2"
key-3 => "value-3"
key-4 => "value-4"
```

[automerge's sync protocol]: https://docs.rs/automerge/latest/automerge/sync/
[iroh's peer-to-peer connectivity]: https://docs.rs/iroh/latest/iroh/net/index.html

================
File: iroh-gateway/self-signed-certs/cert.pem
================
-----BEGIN CERTIFICATE-----
MIIFkzCCA3ugAwIBAgIUQZiKeBISKUZoglT8J8CCPpGbgTkwDQYJKoZIhvcNAQEL
BQAwWTELMAkGA1UEBhMCVVMxEzARBgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoM
GEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZDESMBAGA1UEAwwJbG9jYWxob3N0MB4X
DTIxMDgyOTEyMDE0NVoXDTIyMDgyOTEyMDE0NVowWTELMAkGA1UEBhMCVVMxEzAR
BgNVBAgMClNvbWUtU3RhdGUxITAfBgNVBAoMGEludGVybmV0IFdpZGdpdHMgUHR5
IEx0ZDESMBAGA1UEAwwJbG9jYWxob3N0MIICIjANBgkqhkiG9w0BAQEFAAOCAg8A
MIICCgKCAgEAoeDJnuh1lhcpKCt5VEBqO9JcSoz2wqD3SLj4i2qrEOvqb4X0ZZeN
5GQXQlOG2N6+9FOxTzaTTigTecYzI3hqKn1fiuvaS4EeTC7E1sVOj7tY0yVySjXM
pC/3t1n1s3B25m7eQ0G2JypZFCobGqY0kaRoO+mCTjI4bdCd769shIerCO4Z8FD5
uj1+hBC7ZY/sqmRkGTLX1ZzkXzaeNeWGlkXKU8/V3qdveFQ/sGe+KoZpOPXb0yR7
H8zf6NE2CFCNJDhytOkYLOsnvCJOvibJ3kbM2GfI9iCd0/QhQAOcrVhcOgI4aIxr
wP3zvF4PFUhFKEWHqK5IFq41xKyMYu2fw3bmKXg4zsQGcB0avBD7z+7ENEBvLkNI
7O20wKJp8u0RfjStNHWPmWLXPjkadVB5JHJjsktvgNZkbs9ugxhZWW2AzrrIuqwR
NOWnjHE7J3jvcHP6jE5O9LHpnlh6BMoKPsQuRu/bkrD34rNzwH7IX1To1CyDazMR
yhUiARYh43gg6hrrQdVjDFMHd51mgWHtOPzSLb0uzToglAa3FClGlCeaiacu4H2V
EfJrlCbVlftmIub9/EILZ6XpyYWMxt2mm4mCcMtXmBsHolP4lU3keK8AGNFOr3PC
B7NHLNp1RHgx8+Q3kzobJ1Lk+zEjraWPb5gyByUvZySbd/JTGgNCmZsCAwEAAaNT
MFEwHQYDVR0OBBYEFGsIv6GsbDS+dEWwWlA/3TG5Oi88MB8GA1UdIwQYMBaAFGsI
v6GsbDS+dEWwWlA/3TG5Oi88MA8GA1UdEwEB/wQFMAMBAf8wDQYJKoZIhvcNAQEL
BQADggIBAHhjzP8WtkLJVfZXXUPAAekR7kaqk2hb3hIgDABBJ7xNxcktLOH7V/ng
nhbnwSH5mCkHHXx78TOhWqokHp5wru8K3de5wvAD8uz0UwNDHK5EzqtjYLzxbxAr
ht89WoXGPEZIz6MuOxVYx/HHXdgNEXUcujzfpAfvznVxvzBVqpHNgc7qO8wJd0cG
nit1XubxKoIVTEUjDfxGa2TsmBI7CZ8MLjIyztp/b3txpVl36hPC/uFLwKC780Jc
eO9saA5ISbJh7EaISRr8MKpBpJcraL+055bMjM+kzRFA18NWuuo9Y8fXnXE8e/af
k8FvclVdH/YyezaLkjW7lXjo7QoSXHhAuSzvsGmIsh+HuH+3Fs22AN3aGdmimOmp
7JiNe42mwEpJydwgGlKOysw4ht6MA6yOcQJw73QAYYwusOmNjFZtfCUqJx/JO7mn
Sb1/PW58xYSJhDxdGhoh6Rd3xPMW1T4YwpapkAC/htciK3XkwCcG1VKSmCIErkXf
vllmdahH/QkNooNAHMZl/ipYMik8pp5eRjVjCvpQTDBOI97U0+bgXydHVowP9ExE
dGcm6pP8FU1LyBZdYTdlMRC5Z0L0ltcZn7bqKcyzZB3UcWJv7Uhn3MYbmqGsUVly
a/e3kH2t5pEWRTsrNrRD94LzEYKvcNHy6PYkrgpGjh2G2VBZgNzh
-----END CERTIFICATE-----

================
File: iroh-gateway/self-signed-certs/README.md
================
Self signed certs for testing.

================
File: iroh-gateway/src/args.rs
================
//! Command line arguments.
use std::{
    net::{SocketAddrV4, SocketAddrV6},
    path::PathBuf,
};

use clap::Parser;

#[derive(clap::ValueEnum, Debug, Clone, Copy, PartialEq, Eq)]
pub enum CertMode {
    /// No certificates at all, we serve http.
    None,
    /// Use a self-signed certificate in the cert_path directory.
    Manual,
    /// Use a letsencrypt certificate, in staging mode.
    LetsEncryptStaging,
    /// Use a letsencrypt certificate, in production mode.
    LetsEncrypt,
    // Use a non-letsencrypt CA.
    CustomCA,
}

#[derive(Parser, Debug)]
pub struct Args {
    /// Ticket for the default node.
    ///
    /// This can be a node ticket or a blob ticket. If it is a blob ticket, the
    /// hash is ignored and just the node part is used.
    ///
    /// This is needed for all endpoints except `/ticket`.
    #[clap(long)]
    pub default_node: Option<String>,

    /// Http or https listen addr.
    ///
    /// Will listen on http if cert_path is not specified, https otherwise.
    #[clap(long, default_value = "0.0.0.0:8080")]
    pub addr: String,

    /// The address to use for the ipv4 iroh socket. Random by default.
    #[clap(long, default_value = None)]
    pub iroh_ipv4_addr: Option<SocketAddrV4>,

    /// The address to use for the ipv6 iroh socket. Random by default.
    #[clap(long, default_value = None)]
    pub iroh_ipv6_addr: Option<SocketAddrV6>,

    /// Certificate mode, default is none.
    #[clap(long, default_value = "none")]
    pub cert_mode: CertMode,

    /// Hostnames for letsencrypt.
    #[clap(long, required_if_eq_any([("cert_mode", "LetsEncryptStaging"), ("cert_mode", "LetsEncrypt")]))]
    pub hostname: Vec<String>,

    /// Contact email for letsencrypt.
    #[clap(long, required_if_eq_any([("cert_mode", "LetsEncryptStaging"), ("cert_mode", "LetsEncrypt")]))]
    pub contact: Option<String>,

    /// Certificate path.
    ///
    /// Not needed if cert_mode is None.
    /// In manual mode, this is the directory containing the cert.pem and key.pem files.
    /// In letsencrypt mode, this is the directory used by the acme acceptor.
    #[clap(long, required_if_eq_any([("cert_mode", "LetsEncryptStaging"), ("cert_mode", "LetsEncrypt"), ("cert_mode", "Manual")]))]
    pub cert_path: Option<PathBuf>,

    #[clap(long, required_if_eq_any([("cert_mode", "CustomCA")]))]
    pub acme_directory: Option<String>,

    #[clap(long, default_value = None)]
    pub acme_eab_kid: Option<String>,

    #[clap(long, default_value = None)]
    pub acme_eab_hmac_key: Option<String>,
}

================
File: iroh-gateway/src/cert_util.rs
================
//! Utilities for loading certificates and keys.
use std::path::Path;

use anyhow::{Context, Result};
use rustls::pki_types::{CertificateDer, PrivateKeyDer, pem::PemObject};

pub fn load_certs<'a>(filename: impl AsRef<Path>) -> Result<Vec<CertificateDer<'a>>> {
    println!("loading certs from {}", filename.as_ref().display());
    let certfile = std::fs::File::open(filename).context("cannot open certificate file")?;
    let mut reader = std::io::BufReader::new(certfile);
    let certs = CertificateDer::pem_reader_iter(&mut reader).collect::<Result<Vec<_>, _>>()?;

    Ok(certs)
}

pub fn load_secret_key<'a>(filename: impl AsRef<Path>) -> Result<PrivateKeyDer<'a>> {
    println!("loading secret key from {}", filename.as_ref().display());
    let keyfile = std::fs::File::open(filename.as_ref()).context("cannot open secret key file")?;
    let mut reader = std::io::BufReader::new(keyfile);

    let key = PrivateKeyDer::from_pem_reader(&mut reader)?;

    Ok(key)
}

================
File: iroh-gateway/src/main.rs
================
mod args;
use std::{
    result,
    sync::{Arc, Mutex},
};

use anyhow::Context;
use args::CertMode;
use axum::{
    Extension, Router,
    body::Body,
    extract::Path,
    http::{Method, Request, StatusCode, header},
    response::{IntoResponse, Response},
    routing::get,
};
use bao_tree::{ChunkNum, io::fsm::BaoContentItem};
use base64::{Engine, engine::general_purpose::URL_SAFE_NO_PAD};
use bytes::Bytes;
use clap::Parser;
use derive_more::Deref;
use futures::{StreamExt, pin_mut};
use hyper::body::Incoming;
use hyper_util::rt::{TokioExecutor, TokioIo};
use iroh::{Endpoint, NodeAddr, NodeId, discovery::dns::DnsDiscovery, endpoint::Connection};
use iroh_base::ticket::NodeTicket;
use iroh_blobs::{
    BlobFormat, Hash,
    format::collection::Collection,
    get::fsm::{BlobContentNext, ConnectedNext, DecodeError, EndBlobNext},
    protocol::{ALPN, ChunkRangesSeq},
    ticket::BlobTicket,
};
use lru::LruCache;
use mime::Mime;
use mime_classifier::MimeClassifier;
use range_collections::RangeSet2;
use ranges::parse_byte_range;
use tokio::net::TcpListener;
use tokio_rustls_acme::{AcmeConfig, caches::DirCache, tokio_rustls::TlsAcceptor};
use tower_http::cors::{AllowHeaders, AllowOrigin, CorsLayer};
use tower_service::Service;
use url::Url;

use crate::{
    cert_util::{load_certs, load_secret_key},
    ranges::{slice, to_byte_range, to_chunk_range},
};
mod cert_util;
mod ranges;

// Make our own error that wraps `anyhow::Error`.
struct AppError(anyhow::Error);

// Tell axum how to convert `AppError` into a response.
impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("Something went wrong: {}", self.0),
        )
            .into_response()
    }
}

// This enables using `?` on functions that return `Result<_, anyhow::Error>` to turn them into
// `Result<_, AppError>`. That way you don't need to do that manually.
impl<E> From<E> for AppError
where
    E: Into<anyhow::Error>,
{
    fn from(err: E) -> Self {
        Self(err.into())
    }
}

#[derive(Debug, Clone)]
struct Gateway(Arc<Inner>);

impl Deref for Gateway {
    type Target = Inner;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

type MimeCache = LruCache<(Hash, Option<String>), (u64, Mime)>;

#[derive(derive_more::Debug)]
struct Inner {
    /// Endpoint to connect to nodes
    endpoint: Endpoint,
    /// Default node to connect to when not specified in the url
    default_node: Option<NodeAddr>,
    /// Mime classifier
    #[debug("MimeClassifier")]
    mime_classifier: MimeClassifier,
    /// Cache of hashes to mime types
    mime_cache: Mutex<MimeCache>,
    /// Cache of hashes to collections
    collection_cache: Mutex<LruCache<Hash, Collection>>,
}

impl Inner {
    /// Get the default node to connect to when not specified in the url
    fn default_node(&self) -> anyhow::Result<NodeAddr> {
        let node_addr = self
            .default_node
            .clone()
            .context("default node not configured")?;
        Ok(node_addr)
    }

    /// Get the mime type for a hash from the remote node.
    async fn get_default_connection(&self) -> anyhow::Result<Connection> {
        let connection = self.endpoint.connect(self.default_node()?, ALPN).await?;
        Ok(connection)
    }
}

async fn get_collection_inner(
    hash: &Hash,
    connection: &iroh::endpoint::Connection,
    headers: bool,
) -> anyhow::Result<(Collection, Vec<(Hash, u64, Vec<u8>)>)> {
    let spec = if headers {
        ChunkRangesSeq::from_ranges_infinite(vec![
            RangeSet2::all(),
            RangeSet2::all(),
            RangeSet2::from(..ChunkNum::chunks(2048)),
        ])
    } else {
        ChunkRangesSeq::from_ranges(vec![RangeSet2::all(), RangeSet2::all()])
    };
    let request = iroh_blobs::protocol::GetRequest::new(*hash, spec);
    let req = iroh_blobs::get::fsm::start(connection.clone(), request, Default::default());
    let connected = req.next().await?;
    let ConnectedNext::StartRoot(at_start_root) = connected.next().await? else {
        anyhow::bail!("unexpected response");
    };
    let (mut curr, hash_seq, collection) = Collection::read_fsm(at_start_root).await?;

    let mut headers = Vec::new();
    let at_closing = loop {
        match curr {
            EndBlobNext::Closing(at_closing) => {
                break at_closing;
            }
            EndBlobNext::MoreChildren(at_start_child) => {
                let Some(hash) = hash_seq.get(at_start_child.offset() as usize - 1) else {
                    break at_start_child.finish();
                };
                let at_blob_header = at_start_child.next(hash);
                let (at_blob_content, size) = at_blob_header.next().await?;
                let (at_end_blob, data) = at_blob_content.concatenate_into_vec().await?;
                curr = at_end_blob.next();
                headers.push((hash, size, data));
            }
        }
    };
    let _stats = at_closing.next().await?;

    Ok((collection, headers))
}

/// Get the collection. This will also fill the mime cache.
async fn get_collection(
    gateway: &Gateway,
    hash: &Hash,
    connection: &Connection,
) -> anyhow::Result<Collection> {
    if let Some(res) = gateway.collection_cache.lock().unwrap().get(hash) {
        return Ok(res.clone());
    }
    let (collection, headers) = get_collection_inner(hash, connection, true).await?;

    let mut cache = gateway.mime_cache.lock().unwrap();
    for (name, hash) in collection.iter() {
        let ext = get_extension(name);
        let Some((hash, size, data)) = headers.iter().find(|(h, _, _)| h == hash) else {
            tracing::debug!("hash {hash:?} for name {name:?} not found in headers");
            continue;
        };
        let mime = get_mime_from_ext_and_data(ext.as_deref(), data, &gateway.mime_classifier);
        let key = (*hash, ext);
        cache.put(key, (*size, mime));
    }
    drop(cache);

    gateway
        .collection_cache
        .lock()
        .unwrap()
        .put(*hash, collection.clone());
    Ok(collection)
}

fn get_extension(name: &str) -> Option<String> {
    std::path::Path::new(name)
        .extension()
        .map(|s| s.to_string_lossy().to_string())
}

/// Get the mime type for a hash from the remote node.
async fn get_mime_type_inner(
    hash: &Hash,
    ext: Option<&str>,
    connection: &Connection,
    mime_classifier: &MimeClassifier,
) -> anyhow::Result<(u64, Mime)> {
    // read 2 KiB.
    let range = ChunkRangesSeq::from_ranges(Some(RangeSet2::from(..ChunkNum::chunks(2048))));
    let request = iroh_blobs::protocol::GetRequest::new(*hash, range);
    let req = iroh_blobs::get::fsm::start(connection.clone(), request, Default::default());
    let connected = req.next().await?;
    let ConnectedNext::StartRoot(x) = connected.next().await? else {
        anyhow::bail!("unexpected response");
    };
    let (at_blob_content, size) = x.next().next().await?;
    let (at_end, data) = at_blob_content.concatenate_into_vec().await?;
    let EndBlobNext::Closing(at_closing) = at_end.next() else {
        anyhow::bail!("unexpected response");
    };
    let _stats = at_closing.next().await?;
    let mime = get_mime_from_ext_and_data(ext, &data, mime_classifier);
    Ok((size, mime))
}

fn get_mime_from_ext_and_data(
    ext: Option<&str>,
    data: &[u8],
    mime_classifier: &MimeClassifier,
) -> Mime {
    let context = mime_classifier::LoadContext::Browsing;
    let no_sniff_flag = mime_classifier::NoSniffFlag::On;
    let apache_bug_flag = mime_classifier::ApacheBugFlag::On;
    let supplied_type = match ext {
        None => None,
        Some(ext) => mime_guess::from_ext(ext).first(),
    };
    mime_classifier.classify(
        context,
        no_sniff_flag,
        apache_bug_flag,
        &supplied_type,
        data,
    )
}

/// Get the mime type for a hash, either from the cache or by requesting it from the node.
async fn get_mime_type(
    gateway: &Gateway,
    hash: &Hash,
    name: Option<&str>,
    connection: &Connection,
) -> anyhow::Result<(u64, Mime)> {
    let ext = name.and_then(get_extension);
    let key = (*hash, ext.clone());
    if let Some(sm) = gateway.mime_cache.lock().unwrap().get(&key) {
        return Ok(sm.clone());
    }
    let sm =
        get_mime_type_inner(hash, ext.as_deref(), connection, &gateway.mime_classifier).await?;
    gateway.mime_cache.lock().unwrap().put(key, sm.clone());
    Ok(sm)
}

/// Handle a request for a range of bytes from the default node.
async fn handle_local_blob_request(
    gateway: Extension<Gateway>,
    Path(blake3_hash): Path<Hash>,
    req: Request<Body>,
) -> std::result::Result<Response<Body>, AppError> {
    let connection = gateway.get_default_connection().await?;
    let byte_range = parse_byte_range(req).await?;
    let res = forward_range(&gateway, connection, &blake3_hash, None, byte_range).await?;
    Ok(res)
}

async fn handle_local_collection_index(
    gateway: Extension<Gateway>,
    Path(hash): Path<Hash>,
) -> std::result::Result<impl IntoResponse, AppError> {
    let connection = gateway.get_default_connection().await?;
    let link_prefix = format!("/collection/{hash}");
    let res = collection_index(&gateway, connection, &hash, &link_prefix).await?;
    Ok(res)
}

/// Handle a request for a range of bytes from the default node.
async fn handle_local_collection_request(
    gateway: Extension<Gateway>,
    Path((hash, suffix)): Path<(Hash, String)>,
    req: Request<Body>,
) -> std::result::Result<impl IntoResponse, AppError> {
    let connection = gateway.get_default_connection().await?;
    let byte_range = parse_byte_range(req).await?;
    let res = forward_collection_range(&gateway, connection, &hash, &suffix, byte_range).await?;
    Ok(res)
}

async fn handle_ticket_index(
    gateway: Extension<Gateway>,
    Path(ticket): Path<BlobTicket>,
    req: Request<Body>,
) -> std::result::Result<impl IntoResponse, AppError> {
    tracing::info!("handle_ticket_index");
    let byte_range = parse_byte_range(req).await?;
    let connection = gateway
        .endpoint
        .connect(ticket.node_addr().clone(), ALPN)
        .await?;
    let hash = ticket.hash();
    let prefix = format!("/ticket/{ticket}");
    let res = match ticket.format() {
        BlobFormat::Raw => forward_range(&gateway, connection, &hash, None, byte_range)
            .await?
            .into_response(),
        BlobFormat::HashSeq => collection_index(&gateway, connection, &hash, &prefix)
            .await?
            .into_response(),
    };
    Ok(res)
}

async fn handle_ticket_request(
    gateway: Extension<Gateway>,
    Path((ticket, suffix)): Path<(BlobTicket, String)>,
    req: Request<Body>,
) -> std::result::Result<impl IntoResponse, AppError> {
    tracing::info!("handle_ticket_request");
    let byte_range = parse_byte_range(req).await?;
    let connection = gateway
        .endpoint
        .connect(ticket.node_addr().clone(), ALPN)
        .await?;
    let hash = ticket.hash();
    let res = forward_collection_range(&gateway, connection, &hash, &suffix, byte_range).await?;
    Ok(res)
}

async fn collection_index(
    gateway: &Gateway,
    connection: Connection,
    hash: &Hash,
    link_prefix: &str,
) -> anyhow::Result<impl IntoResponse + use<>> {
    fn encode_relative_url(relative_url: &str) -> anyhow::Result<String> {
        let base = Url::parse("http://example.com")?;
        let joined_url = base.join(relative_url)?;

        Ok(joined_url[url::Position::BeforePath..].to_string())
    }

    let collection = get_collection(gateway, hash, &connection).await?;
    let mut res = String::new();
    res.push_str("<html>\n<head></head>\n");

    for (name, child_hash) in collection.iter() {
        let url = format!("{link_prefix}/{name}");
        let url = encode_relative_url(&url)?;
        let key = (*child_hash, get_extension(name));
        let smo = gateway.mime_cache.lock().unwrap().get(&key).cloned();
        res.push_str(&format!("<a href=\"{url}\">{name}</a>",));
        if let Some((size, mime)) = smo {
            res.push_str(&format!(" ({}, {})", mime, indicatif::HumanBytes(size)));
        }
        res.push_str("<br>\n");
    }
    res.push_str("</body>\n</html>\n");
    let response = Response::builder()
        .status(StatusCode::OK)
        .header(header::CONTENT_TYPE, "text/html")
        .header(header::CACHE_CONTROL, "max-age=3600")
        .body(res)?;
    Ok((StatusCode::OK, response).into_response())
}

async fn forward_collection_range(
    gateway: &Gateway,
    connection: Connection,
    hash: &Hash,
    suffix: &str,
    range: (Option<u64>, Option<u64>),
) -> anyhow::Result<impl IntoResponse + use<>> {
    let suffix = suffix.strip_prefix('/').unwrap_or(suffix);
    tracing::trace!("suffix {}", suffix);
    let collection = get_collection(gateway, hash, &connection).await?;
    for (name, hash) in collection.iter() {
        if name == suffix {
            let res = forward_range(gateway, connection, hash, Some(suffix), range).await?;
            return Ok(res.into_response());
        } else {
            tracing::trace!("'{}' != '{}'", name, suffix);
        }
    }
    Ok((
        StatusCode::NOT_FOUND,
        format!("entry '{suffix}' not found in collection '{hash}'"),
    )
        .into_response())
}

fn format_content_range(start: Option<u64>, end: Option<u64>, size: u64) -> String {
    format!(
        "bytes {}-{}/{}",
        start.map(|x| x.to_string()).unwrap_or_default(),
        end.map(|x| (x + 1).to_string())
            .unwrap_or_else(|| size.to_string()),
        size
    )
}

async fn forward_range(
    gateway: &Gateway,
    connection: Connection,
    hash: &Hash,
    name: Option<&str>,
    (start, end): (Option<u64>, Option<u64>),
) -> anyhow::Result<Response<Body>> {
    // we need both byte ranges and chunk ranges.
    // chunk ranges to request data, and byte ranges to return the data.
    tracing::debug!("forward_range {:?} {:?} (name {name:?})", start, end);

    let byte_ranges = to_byte_range(start, end);
    let chunk_ranges = to_chunk_range(start, end);
    tracing::debug!("got connection");
    let (_size, mime) = get_mime_type(gateway, hash, name, &connection).await?;
    tracing::debug!("mime: {}", mime);
    let chunk_ranges = ChunkRangesSeq::from_ranges(vec![chunk_ranges]);
    let request = iroh_blobs::protocol::GetRequest::new(*hash, chunk_ranges.clone());
    let status_code = if byte_ranges.is_all() {
        StatusCode::OK
    } else {
        StatusCode::PARTIAL_CONTENT
    };
    tracing::debug!("status_code {}", status_code);
    let (send, recv) = flume::bounded::<result::Result<Bytes, DecodeError>>(2);

    tracing::trace!("requesting {:?}", request);
    let req = iroh_blobs::get::fsm::start(connection.clone(), request, Default::default());
    let connected = req.next().await?;
    let ConnectedNext::StartRoot(x) = connected.next().await? else {
        anyhow::bail!("unexpected response");
    };
    tracing::trace!("connected");
    let (mut current, size) = x.next().next().await?;
    tokio::spawn(async move {
        let end = loop {
            match current.next().await {
                BlobContentNext::More((next, Ok(item))) => {
                    match item {
                        BaoContentItem::Leaf(leaf) => {
                            tracing::trace!("got leaf {} {}", leaf.offset, leaf.data.len());
                            for item in slice(leaf.offset, leaf.data, byte_ranges.clone()) {
                                send.send_async(Ok(item)).await?;
                            }
                        }
                        BaoContentItem::Parent(parent) => {
                            tracing::trace!("got parent {:?}", parent);
                        }
                    }
                    current = next;
                }
                BlobContentNext::More((_, Err(err))) => {
                    send.send_async(Err(err)).await?;
                    anyhow::bail!("error");
                }
                BlobContentNext::Done(end) => break end,
            }
        };
        let EndBlobNext::Closing(at_closing) = end.next() else {
            anyhow::bail!("unexpected response");
        };
        let _stats = at_closing.next().await?;
        Ok(())
    });
    let body = Body::from_stream(recv.into_stream());
    let builder = Response::builder()
        .status(status_code)
        .header(header::ACCEPT_RANGES, "bytes")
        .header(header::CACHE_CONTROL, "public,max-age=31536000,immutable")
        .header(header::CONTENT_TYPE, mime.to_string());
    // content-length needs to be the actual repsonse size
    let transfer_size = match (start, end) {
        (Some(start), Some(end)) => end - start,
        (Some(start), None) => size - start,
        (None, Some(end)) => end,
        (None, None) => size,
    };
    let builder = builder.header(header::CONTENT_LENGTH, transfer_size);

    let builder = if start.is_some() || end.is_some() {
        builder
            .header(
                header::CONTENT_RANGE,
                format_content_range(start, end, size),
            )
            .status(StatusCode::PARTIAL_CONTENT)
    } else {
        builder
    };
    let response = builder.body(body).unwrap();
    Ok(response)
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt::init();
    rustls::crypto::ring::default_provider()
        .install_default()
        .unwrap();
    let args = args::Args::parse();
    let mut builder = Endpoint::builder().discovery(DnsDiscovery::n0_dns());
    if let Some(addr) = args.iroh_ipv4_addr {
        builder = builder.bind_addr_v4(addr);
    }
    if let Some(addr) = args.iroh_ipv6_addr {
        builder = builder.bind_addr_v6(addr);
    }
    let endpoint = builder.bind().await?;
    let default_node = args
        .default_node
        .map(|default_node| {
            Ok(if let Ok(node_id) = default_node.parse::<NodeId>() {
                node_id.into()
            } else if let Ok(node_ticket) = default_node.parse::<NodeTicket>() {
                node_ticket.node_addr().clone()
            } else if let Ok(blob_ticket) = default_node.parse::<BlobTicket>() {
                blob_ticket.node_addr().clone()
            } else {
                anyhow::bail!("invalid default node");
            })
        })
        .transpose()?;
    let gateway = Gateway(Arc::new(Inner {
        endpoint,
        default_node,
        mime_classifier: MimeClassifier::new(),
        mime_cache: Mutex::new(LruCache::new(100000.try_into().unwrap())),
        collection_cache: Mutex::new(LruCache::new(1000.try_into().unwrap())),
    }));

    let cors = CorsLayer::new()
        .allow_headers(AllowHeaders::mirror_request())
        .allow_methods([Method::GET, Method::HEAD, Method::OPTIONS])
        .allow_origin(AllowOrigin::mirror_request());

    #[rustfmt::skip]
    let app = Router::new()
        .route("/blob/:blake3_hash", get(handle_local_blob_request))
        .route("/collection/:blake3_hash", get(handle_local_collection_index))
        .route("/collection/:blake3_hash/*path",get(handle_local_collection_request))
        .route("/ticket/:ticket", get(handle_ticket_index))
        .route("/ticket/:ticket/*path", get(handle_ticket_request))
        .layer(cors)
        .layer(Extension(gateway));

    match args.cert_mode {
        CertMode::None => {
            // Run our application as just http
            let addr = args.addr;
            println!("listening on {addr}, http");

            let listener = tokio::net::TcpListener::bind(addr).await?;
            axum::serve(listener, app).await?;
        }
        CertMode::Manual => {
            // Run with manual certificates
            //
            // Code copied from https://github.com/tokio-rs/axum/tree/main/examples/low-level-rustls/src
            //
            // TODO: use axum_server maybe, once tokio-rustls-acme is on the latest
            // rustls.
            let cert_path = args
                .cert_path
                .context("cert_path not specified")?
                .canonicalize()?;
            let cert_file = cert_path.join("cert.pem");
            let key_file = cert_path.join("key.pem");
            let certs = load_certs(cert_file)?;
            let secret_key = load_secret_key(key_file)?;
            let config = rustls::ServerConfig::builder()
                .with_no_client_auth()
                .with_single_cert(certs, secret_key)?;
            // Run our application with hyper
            let addr = args.addr;
            println!("listening on {addr}");
            println!("https with manual certificates");
            let tls_acceptor = TlsAcceptor::from(Arc::new(config));
            let tcp_listener = TcpListener::bind(addr).await?;

            pin_mut!(tcp_listener);

            loop {
                let tower_service = app.clone();
                let tls_acceptor = tls_acceptor.clone();

                // Wait for new tcp connection
                let (cnx, addr) = tcp_listener.accept().await?;

                tokio::spawn(async move {
                    // Wait for tls handshake to happen
                    let Ok(stream) = tls_acceptor.accept(cnx).await else {
                        tracing::error!("error during tls handshake connection from {}", addr);
                        return;
                    };

                    // Hyper has its own `AsyncRead` and `AsyncWrite` traits and doesn't use tokio.
                    // `TokioIo` converts between them.
                    let stream = TokioIo::new(stream);

                    // Hyper has also its own `Service` trait and doesn't use tower. We can use
                    // `hyper::service::service_fn` to create a hyper `Service` that calls our app through
                    // `tower::Service::call`.
                    let hyper_service =
                        hyper::service::service_fn(move |request: Request<Incoming>| {
                            // We have to clone `tower_service` because hyper's `Service` uses `&self` whereas
                            // tower's `Service` requires `&mut self`.
                            //
                            // We don't need to call `poll_ready` since `Router` is always ready.
                            tower_service.clone().call(request)
                        });

                    let ret = hyper_util::server::conn::auto::Builder::new(TokioExecutor::new())
                        .serve_connection_with_upgrades(stream, hyper_service)
                        .await;

                    if let Err(err) = ret {
                        tracing::warn!("error serving connection from {}: {}", addr, err);
                    }
                });
            }
        }
        CertMode::LetsEncryptStaging | CertMode::LetsEncrypt | CertMode::CustomCA => {
            // Run with letsencrypt certificates
            //
            // Code copied from https://github.com/tokio-rs/axum/tree/main/examples/low-level-rustls/src and adapted
            //
            // TODO: use axum_server with the axum acceptor maybe, once tokio-rustls-acme is on the latest
            // rustls.
            let is_production = args.cert_mode == CertMode::LetsEncrypt;
            let hostnames = args.hostname;
            let contact = args.contact.context("contact not specified")?;
            let dir = args.cert_path.context("cert_path not specified")?;
            let mut acme_config = AcmeConfig::new(hostnames.clone())
                .contact([format!("mailto:{contact}")])
                .cache_option(Some(DirCache::new(dir)))
                .directory_lets_encrypt(is_production);

            if args.cert_mode == CertMode::CustomCA {
                let eab_key = URL_SAFE_NO_PAD.decode(args.acme_eab_hmac_key.unwrap())?;

                acme_config = acme_config
                    .directory(args.acme_directory.unwrap())
                    .external_account_binding(args.acme_eab_kid.unwrap(), eab_key);
            }

            let state = acme_config.state();
            let config = rustls::ServerConfig::builder()
                .with_no_client_auth()
                .with_cert_resolver(state.resolver());
            // config.alpn_protocols.extend([b"h2".to_vec(), b"http/1.1".to_vec()]);
            let config = Arc::new(config);
            let acme_acceptor = state.acceptor();
            // drive the acme state machine
            //
            // this drives the cert renewal process.
            tokio::spawn(async move {
                let mut state = state;
                while let Some(event) = state.next().await {
                    match event {
                        Ok(ok) => tracing::debug!("acme event: {:?}", ok),
                        Err(err) => tracing::error!("error: {:?}", err),
                    }
                }
            });
            // Run our application with hyper
            let addr = args.addr;
            println!("listening on {addr}");
            println!("https with letsencrypt certificates, production = {is_production}");
            println!(
                "https hostnames = {}",
                Vec::from_iter(hostnames.iter().map(|i| i.to_string())).join(", ")
            );
            let tcp_listener = TcpListener::bind(addr).await?;

            pin_mut!(tcp_listener);

            loop {
                let tower_service = app.clone();
                let acme_acceptor = acme_acceptor.clone();
                let config = config.clone();

                // Wait for new tcp connection
                let (cnx, addr) = tcp_listener.accept().await?;
                println!("got connection from {addr}");

                tokio::spawn(async move {
                    // Wait for tls handshake to happen
                    let handshake = match acme_acceptor.accept(cnx).await {
                        Ok(Some(handshake)) => {
                            tracing::info!("got tls handshake from {}", addr);
                            handshake
                        }
                        Ok(None) => {
                            tracing::info!("got acme tls challenge from {}", addr);
                            return Ok(());
                        }
                        Err(cause) => {
                            tracing::error!(
                                "error during tls handshake connection from {}: {}",
                                addr,
                                cause
                            );
                            return Ok(());
                        }
                    };
                    let stream = match handshake.into_stream(config.clone()).await {
                        Ok(stream) => stream,
                        Err(cause) => {
                            tracing::error!(
                                "error during tls handshake connection from {}: {}",
                                addr,
                                cause
                            );
                            return Ok(());
                        }
                    };

                    // Hyper has its own `AsyncRead` and `AsyncWrite` traits and doesn't use tokio.
                    // `TokioIo` converts between them.
                    let stream = TokioIo::new(stream);

                    // Hyper has also its own `Service` trait and doesn't use tower. We can use
                    // `hyper::service::service_fn` to create a hyper `Service` that calls our app through
                    // `tower::Service::call`.
                    let hyper_service =
                        hyper::service::service_fn(move |request: Request<Incoming>| {
                            // We have to clone `tower_service` because hyper's `Service` uses `&self` whereas
                            // tower's `Service` requires `&mut self`.
                            //
                            // We don't need to call `poll_ready` since `Router` is always ready.
                            tower_service.clone().call(request)
                        });

                    let ret = hyper_util::server::conn::auto::Builder::new(TokioExecutor::new())
                        .serve_connection_with_upgrades(stream, hyper_service)
                        .await;

                    if let Err(err) = ret {
                        tracing::warn!("error serving connection from {}: {}", addr, err);
                    }
                    anyhow::Ok(())
                });
            }
        }
    }

    Ok(())
}

================
File: iroh-gateway/src/ranges.rs
================
//! Utilities related to HTTP range requests.
use std::ops::Bound;

use axum::body::Body;
use bao_tree::ChunkNum;
use bytes::Bytes;
use headers::{HeaderMapExt, Range};
use hyper::Request;
use range_collections::{RangeSet2, range_set::RangeSetRange};

/// Given a range specified as arbitrary range bounds, normalize it into a range
/// that has inclusive start and exclusive end.
fn normalize_range(start: Bound<u64>, end: Bound<u64>) -> (Option<u64>, Option<u64>) {
    match (start, end) {
        (Bound::Included(start), Bound::Included(end)) => (Some(start), end.checked_add(1)),
        (Bound::Included(start), Bound::Excluded(end)) => (Some(start), Some(end)),
        (Bound::Included(start), Bound::Unbounded) => (Some(start), None),
        (Bound::Excluded(start), Bound::Included(end)) => {
            (start.checked_add(1), end.checked_add(1))
        }
        (Bound::Excluded(start), Bound::Excluded(end)) => (start.checked_add(1), Some(end)),
        (Bound::Excluded(start), Bound::Unbounded) => (start.checked_add(1), None),
        (Bound::Unbounded, Bound::Included(end)) => (None, end.checked_add(1)),
        (Bound::Unbounded, Bound::Excluded(end)) => (None, Some(end)),
        (Bound::Unbounded, Bound::Unbounded) => (None, None),
    }
}

/// Convert a normalized range into a `RangeSet2<u64>` that represents the byte range.
pub fn to_byte_range(start: Option<u64>, end: Option<u64>) -> RangeSet2<u64> {
    match (start, end) {
        (Some(start), Some(end)) => RangeSet2::from(start..end),
        (Some(start), None) => RangeSet2::from(start..),
        (None, Some(end)) => RangeSet2::from(..end),
        (None, None) => RangeSet2::all(),
    }
}

/// Convert a normalized range into a `RangeSet2<ChunkNum>` that represents the chunk range.
///
/// Ranges are rounded up so that the given byte range is completely covered by the chunk range.
pub fn to_chunk_range(start: Option<u64>, end: Option<u64>) -> RangeSet2<ChunkNum> {
    match (start, end) {
        (Some(start), Some(end)) => {
            RangeSet2::from(ChunkNum::full_chunks(start)..ChunkNum::chunks(end))
        }
        (Some(start), None) => RangeSet2::from(ChunkNum::full_chunks(start)..),
        (None, Some(end)) => RangeSet2::from(..ChunkNum::chunks(end)),
        (None, None) => RangeSet2::all(),
    }
}

/// Given an incoming piece of data at an offset, and a set of ranges that are being requested,
/// split the data into parts that cover only requested ranges
pub fn slice(offset: u64, data: Bytes, ranges: RangeSet2<u64>) -> Vec<Bytes> {
    let len = data.len() as u64;
    let data_range = to_byte_range(Some(offset), offset.checked_add(len));
    let relevant = ranges & data_range;
    relevant
        .iter()
        .map(|range| match range {
            RangeSetRange::Range(range) => {
                let start = (range.start - offset) as usize;
                let end = (range.end - offset) as usize;
                data.slice(start..end)
            }
            RangeSetRange::RangeFrom(range) => {
                let start = (range.start - offset) as usize;
                data.slice(start..)
            }
        })
        .collect()
}

/// Parse the byte range from the request headers.
pub async fn parse_byte_range(req: Request<Body>) -> anyhow::Result<(Option<u64>, Option<u64>)> {
    Ok(match req.headers().typed_get::<Range>() {
        Some(range) => {
            println!("got range request {range:?}");
            let ranges = range.satisfiable_ranges(0).collect::<Vec<_>>();
            if ranges.len() > 1 {
                anyhow::bail!("multiple ranges not supported");
            }
            let Some((start, end)) = ranges.into_iter().next() else {
                anyhow::bail!("empty range");
            };
            normalize_range(start, end)
        }
        None => (None, None),
    })
}

================
File: iroh-gateway/systemd/iroh-gateway-https.service
================
[Unit]
Description=Iroh Gateway Service Https
After=network.target

[Service]
ExecStart=/root/bin/iroh-gateway \
    --addr 0.0.0.0:443 \ # listen on all interfaces at port 443
    --cert-mode lets-encrypt \ # lets-encrypt production mode
    --hostname myhostname.org \ # public hostname. you can have multiple
    --contact admin@mycompany.org \ # admin email for letsencrypt
    --cert-path ./letsencrypt \ # work dir for letsencrypt, relative to work dir
    --default-node <blob ticket or node ticket>
WorkingDirectory=/root/services/iroh-gateway
Restart=always
User=root
Group=root
Environment="RUST_LOG=info"

[Install]
WantedBy=multi-user.target

================
File: iroh-gateway/systemd/iroh-gateway.service
================
[Unit]
Description=Iroh Gateway Service
After=network.target

[Service]
ExecStart=/root/bin/iroh-gateway \
    --addr 0.0.0.0:8080 \ # listen on all interfaces, port 8080
    --default-node <blob ticket or node ticket>
WorkingDirectory=/root/services/iroh-gateway
Restart=always
User=root
Group=root
Environment="RUST_LOG=info"

[Install]
WantedBy=multi-user.target

================
File: iroh-gateway/systemd/README.md
================
Example systemd files to run iroh gateway.

Adapt directories and users as needed.

================
File: iroh-gateway/.gitignore
================
/target
iroh.config.toml

================
File: iroh-gateway/Cargo.toml
================
[package]
name = "iroh-gateway"
version = "0.1.0"
edition = "2024"

[dependencies]
axum = "0.7.3"
base64 = "0.22"
tokio = { version = "1", features = ["full"] }
headers = { version = "0.4" }
hyper = "1"
bytes = "1.1"
iroh = "0.90"
iroh-base = "0.90"
iroh-blobs = "0.90"
range-collections = "0.4.5"
anyhow = "1.0.75"
flume = "0.11.0"
tracing = "0.1.40"
tower-http = { version = "0.5.0", features = ["cors"] }
clap = { version = "4.4.7", features = ["derive"] }
mime_classifier = "0.0.1"
derive_more = { version = "1.0.0-beta.1", features = ["debug"] }
mime = "0.3.17"
url = "2.4.1"
futures = "0.3.29"
lru = "0.12.1"
tracing-subscriber = "0.3.18"
indicatif = "0.17.7"
rustls = "0.23"
tokio-rustls-acme = "0.7.0"
hyper-util = "0.1.3"
rustls-pemfile = "1.0.2"
tower-service = "0.3.2"
mime_guess = "2.0.4"
bao-tree = "0.15.1"

================
File: iroh-gateway/README.md
================
# Iroh gateway example

This is a stateless http gateway. It can be used to serve content from
a local or remote iroh node.

It will connect to the local iroh node via the iroh-blobs protocol.

# Prerequisites

Make sure you have an up to date version of [rust](https://www.rust-lang.org/) installed. Use the
[rustup](https://rustup.rs/) tool to get the rust compiler `rustc` and build tool
`cargo` for your platform.

# Usage

First find or start an iroh node that has content you want to view:

```
 iroh start ~/Downloads/my_video.mp4
Listening addresses:
  x.x.x.x:xxxxx
  x.x.x.x:xxxxx
DERP Region: 2
PeerID: cytwbysn6cs6jbhdak6ypmrbg2w3nrcrptl5xlts2yurk4mq5cb

...

Blob: bafkr4ibwueokpaxz3x6fd2tvsdo3uqixzimulg536abicpqmqtt3itaodt
```

Then start the gateway and point it to the node above:
```
> cargo run --default_node cytwbysn6cs6jbhdak6ypmrbg2w3nrcrptl5xlts2yurk4mq5cb
```

Then access content from a browser. Since this supports range requests, you can e.g. stream a video, including seeking in the video, with a supporting player.

```
http://localhost:8080/blob/bafkr4ibwueokpaxz3x6fd2tvsdo3uqixzimulg536abicpqmqtt3itaodt
```

To access content from a node other than the default one, you can explicitly specify it in the URL:

```
http://localhost:8080/node/cytwbysn6cs6jbhdak6ypmrbg2w3nrcrptl5xlts2yurk4mq5cb/blob/bafkr4ibwueokpaxz3x6fd2tvsdo3uqixzimulg536abicpqmqtt3itaodt
```

# Features
- [x] range requests
- [x] mime type sniffing

================
File: tauri-todos/src/component/OpenList.tsx
================
import { useState } from "react";

const OpenList: React.FC<{ createList: () => void, joinList: (ticket: string) => void }> = ({ createList, joinList}) => {
    const [ticket, setTicket] = useState('');
  return (
    <>
      <header className="header">
        <h1>todos</h1>
      </header>
      <footer className="footer" style={{ height:"auto"}}>
          <p style={{ fontWeight:400, padding:0, margin:0 }}>Open a new todo list or input a ticket to join an active one:</p>
          <div style={{margin:20, display: "flex", justifyContent:"center"}}>
            <div style={{width: 100}}>
                <a onClick={createList} style={{ color: "#b83f45", cursor: "pointer" }}>Create New List </a>
            </div>
          </div>
          <div style={{margin:20, display: "flex", justifyContent:"space-between"}}>
            <input style={
                { 
                    background: "#f5f5f5",
                    boxShadow: "0 2px 4px 0 rgba(0, 0, 0, 0.2), 0 25px 50px 0 rgba(0, 0, 0, 0.1)",
                    border: "1px solid #e6e6e6",
                    flexGrow: 1,
                    paddingLeft: 10,
                    marginRight: 10,
                }} 
                value={ticket}
                onChange={(e) => { setTicket(e.target.value) }}
                type="text" 
                placeholder='input a ticket to join a list'
            />
            <a onClick={() => joinList(ticket)}style={{width: 110, cursor: "pointer", color:"#b83f45"}}>Join Using Ticket </a>
          </div>
      </footer>
    </>
  )
}
export default OpenList

================
File: tauri-todos/src/component/TodoItem.tsx
================
import { useAtom } from 'jotai'
import { ChangeEventHandler, KeyboardEventHandler, useCallback, useRef, useState } from 'react'
import { useClickAway } from 'react-use'
import { useDebouncedCallback } from 'use-debounce'
import { allTodosAtom } from '../store/todos'
import { Todo } from '../types/todo'
import { useDoubleClick } from '../hooks/useDoubleClick'
import { invoke } from '@tauri-apps/api/core'

const TodoItem: React.FC<{ todo: Todo }> = ({ todo }) => {
  const [, setTodos] = useAtom(allTodosAtom)
  const [editing, setEditing] = useState(false)
  const ref = useRef<HTMLInputElement>(null)

  const toggleDone = useDebouncedCallback(() => {
    invoke('toggle_done', { id: todo.id })
  }, 500)

  const setLabel = useDebouncedCallback((label: string) => {
    invoke('update_todo', {
      todo: { ...todo, label }
    })
  }, 500)

  const deleteTodo = useCallback(() => {
    invoke('delete', { id: todo.id })
  }, [todo])

  const onDelete = () => {
    setTodos((todos) => {
      return todos.filter((t) => {
        return t.id !== todo.id
      })
    })
    deleteTodo()
  }

  const onChange: ChangeEventHandler<HTMLInputElement> = (e) => {
    const label = e?.target.value
    setTodos((todos) => {
      return todos.map((t) => {
        if (t.id === todo.id) {
          setLabel(label)
          return { ...t, label }
        }
        return t
      })
    })
  }

  useClickAway(ref, () => {
    finishEditing()
  })

  const finishEditing = useCallback(() => {
    setEditing(false)
  }, [todo])

  const handleViewClick = useDoubleClick(null, () => {
    setEditing(true)
  })

  const onDone = useCallback(() => {
    setTodos((todos) => {
      return todos.map((t) => {
        if (t.id === todo.id) {
          toggleDone()
          return { ...t, done: !t.done }
        }
        return t
      })
    })
  }, [todo.id])

  const onEnter = useCallback<KeyboardEventHandler<HTMLInputElement>>(
    (event) => {
      if (event.key === 'Enter') {
        event.preventDefault()
        finishEditing()
      }
    },
    [todo]
  )
  return (
    <li
      className={[editing && 'editing', todo.done && 'completed'].filter(Boolean).join(' ')}
      onClick={handleViewClick}
    >
      <div className="view">
        <input type="checkbox" className="toggle" checked={todo.done} onChange={onDone} autoFocus />
        <label>{todo.label}</label>
        <button className="destroy" onClick={onDelete}></button>
      </div>
      {editing && (
        <input
          ref={ref}
          type="text"
          autoFocus={true}
          value={todo.label}
          onChange={onChange}
          className="edit"
          onKeyDown={onEnter}
        />
      )}
    </li>
  )
}
export default TodoItem

================
File: tauri-todos/src/component/TodoList.tsx
================
import { useAtom } from 'jotai'
import { v4 as randomUUID } from 'uuid'
import { useState, useCallback, KeyboardEventHandler, useEffect } from 'react'
import { activeTodoCountAtom, allTodosAtom, anyTodosDone, filterType } from '../store/todos'
import { Todo } from '../types/todo'
import TodoItem from './TodoItem'
import { invoke } from '@tauri-apps/api/core'

const TodoList: React.FC<{ todos: Todo[] }> = ({ todos }) => {
  const [ticket, setTicket] = useState('');
  const [, setTodos] = useAtom(allTodosAtom)
  const [type, setType] = useAtom(filterType)
  const [activeCount] = useAtom(activeTodoCountAtom)
  const [anyDone] = useAtom(anyTodosDone)

  const [newTodo, setNewTodo] = useState('')

  useEffect(() => {
    invoke<string>('get_ticket').then((res) => {
        console.log("get ticket");
        console.log(res);
        setTicket(res)
    })
  }, [])

  const addTodo = async (label: string, id: string) => {
    invoke('new_todo', { todo: { id, label, done: false, is_delete: false, created: 0 } })
  }

  const onAddTodo = useCallback<KeyboardEventHandler<HTMLInputElement>>(
    (e) => {
      if (e.key === 'Enter') {
        e.preventDefault()
        if (newTodo) {
          const id = randomUUID()
          addTodo(newTodo, id)
          setTodos((oldTodos) => {
            return [...oldTodos, { label: newTodo, id, done: false } as Todo]
          })
          setNewTodo('')
        }
      }
    },
    [newTodo]
  )

  const onClearComplete = () => {
    setTodos((oldTodos) => {
      return oldTodos.filter((todo) => {
        const isDone = todo.done
        if (isDone) {
          invoke('delete', { id: todo.id })
          return false
        }
        return true
      })
    })
  }
  return (
    <>
      <header className="header">
        <h1>todos</h1>
        <a style={
          {
            position: "absolute",
            width: "100%",
            textAlign: "center",
            color: "#b83f45",
            top: -30,
            cursor: "pointer",
          }
        } onClick={() => navigator.clipboard.writeText(ticket)}>Copy Ticket</a>
        <input
          type="text"
          className="new-todo"
          value={newTodo}
          onChange={(e) => {
            setNewTodo(e.target.value)
          }}
          onKeyDown={onAddTodo}
          placeholder="What needs to be done?"
        />
      </header>
      <section className="main">
        <input type="checkbox" className="toggle-all" />
        <label htmlFor="togle-all"></label>
        <ul className="todo-list">
          {todos.map((todo) => (
            <TodoItem key={todo.id} todo={todo} />
          ))}
        </ul>
      </section>
      <footer className="footer">
        <span className="todo-count">
          <strong>{activeCount}</strong> items left
        </span>
        <ul className="filters">
          <li>
            <a onClick={() => setType('all')} className={type == 'all' ? 'selected' : ''}>
              All
            </a>
          </li>
          <li>
            <a onClick={() => setType('active')} className={type == 'active' ? 'selected' : ''}>
              Active
            </a>
          </li>
          <li>
            <a onClick={() => setType('completed')} className={type == 'completed' ? 'selected' : ''}>
              Completed
            </a>
          </li>
        </ul>
        {anyDone && (
          <button className="clear-completed" onClick={onClearComplete}>
            Clear completed
          </button>
        )}
      </footer>
    </>
  )
}
export default TodoList

================
File: tauri-todos/src/hooks/useDoubleClick.ts
================
import { MouseEventHandler, MouseEvent, EventHandler } from 'react'

type ClickEvent = EventHandler<MouseEvent<HTMLLIElement>> | null

export function useDoubleClick(onClick: ClickEvent, onDoubleClick: ClickEvent): MouseEventHandler<HTMLLIElement> {
  let clicks: number[] = []
  let timeout: number

  return (event) => {
    clicks.push(new Date().getTime())

    clearTimeout(timeout)
    timeout = window.setTimeout(() => {
      if (clicks.length > 1 && clicks[clicks.length - 1] - clicks[clicks.length - 2] < 250) {
        if (onDoubleClick) {
          onDoubleClick(event)
        }
      } else if (onClick) {
        onClick(event)
      }
      clicks = []
    }, 250)
  }
}

================
File: tauri-todos/src/store/todos.ts
================
import { atom } from 'jotai'
import { Todo } from '../types/todo'

/** filter type controls */
export const filterType = atom<'all' | 'completed' | 'active'>('all')

/** all todos contains deleted */
export const allTodosAtom = atom<Todo[]>([])

/** all undeleted todos */
export const todosAtom = atom<Todo[]>((get) => {
  const todos = get(allTodosAtom)
  return todos.filter((todo) => !todo.is_delete)
})

/** filtered todos */
export const filterAtom = atom((get) => {
  const todos = get(todosAtom)
  return todos.filter((todo) => {
    if (get(filterType) === 'all') return true
    return todo.done === (get(filterType) === 'completed')
  })
})

/** active todos count */
export const activeTodoCountAtom = atom((get) => {
  const todos = get(todosAtom)
  return todos.filter((todo) => !todo.done).length
})

/** is any todos done */
export const anyTodosDone = atom((get) => {
  const todos = get(todosAtom)
  return todos.some((todo) => todo.done)
})

================
File: tauri-todos/src/types/todo.ts
================
export interface Todo {
  id: string
  created: number
  label: string
  done: boolean
  is_delete: boolean
}

================
File: tauri-todos/src/App.tsx
================
import { invoke } from '@tauri-apps/api/core'
import { listen } from '@tauri-apps/api/event'
import { useAtom } from 'jotai'
import { useEffect, useState } from 'react'
import TodoList from './component/TodoList'
import OpenList from './component/OpenList'
import { allTodosAtom, filterAtom } from './store/todos'
import { Todo } from './types/todo'

function App() {
  const [, setAllTodos] = useAtom(allTodosAtom)
  const [todos] = useAtom(filterAtom)
  const [showOpenList, setShowOpenList] = useState(true);

  useEffect(() => {
    listen('update-all', (event) => {
      console.log("updating", event)
      getTodos() 
    })
  }, [])

  function createList() {
    console.log("create list");
    invoke('new_list').then(() => {
      console.log("in new_list and then");
       getTodos(); 
       setShowOpenList(false);
    })
  }

  function joinList(ticket:string) {
    console.log("join list");
    setTicket(ticket);
    getTodos();
    setShowOpenList(false);
  }

  function setTicket(ticket: string) {
    // this is the effect for the modal
    // otherwise just get-todos
    invoke<Todo[]>('set_ticket', {ticket}).then(() => {
      getTodos()
    })
  }

  function getTodos() {
    invoke<Todo[]>('get_todos').then((res) => {
      setAllTodos(res)
    }).then(()=> {
      setShowOpenList(false)
    })
  }

  return (
    <div className="todoapp">
      {showOpenList && <OpenList createList={createList} joinList={joinList}/>}
      {!showOpenList && <TodoList todos={todos} />}
    </div>
  )
}

export default App

================
File: tauri-todos/src/main.tsx
================
import React from 'react'
import ReactDOM from 'react-dom/client'

import App from './App'
import 'todomvc-app-css/index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)

================
File: tauri-todos/src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: tauri-todos/src-tauri/capabilities/default.json
================
{
  "$schema": "../gen/schemas/desktop-schema.json",
  "identifier": "default",
  "description": "Capability for the main window",
  "windows": ["main"],
  "permissions": [
    "core:default",
    "opener:default"
  ]
}

================
File: tauri-todos/src-tauri/src/ipc.rs
================
use anyhow::Result;

use crate::{
    state::AppState,
    todos::{Todo, Todos},
};

#[tauri::command]
pub async fn get_todos(state: tauri::State<'_, AppState>) -> Result<Vec<Todo>, String> {
    if let Some((todos, _)) = &mut *state.todos.lock().await {
        let todos = todos.get_todos().await.map_err(|e| e.to_string())?;
        return Ok(todos);
    }
    Err("not initialized".to_string())
}

#[tauri::command]
pub async fn new_list(
    app_handle: tauri::AppHandle,
    state: tauri::State<'_, AppState>,
) -> Result<(), String> {
    let todos = Todos::new(None, state.iroh().clone())
        .await
        .map_err(|e| e.to_string())?;

    state
        .init_todos(app_handle, todos)
        .await
        .map_err(|e| e.to_string())?;

    Ok(())
}

#[tauri::command]
pub async fn new_todo(todo: Todo, state: tauri::State<'_, AppState>) -> Result<(), String> {
    if let Some((todos, _)) = &mut *state.todos.lock().await {
        todos
            .add(todo.id, todo.label)
            .await
            .map_err(|e| e.to_string())?;
        return Ok(());
    }
    Err("not initialized".to_string())
}

#[tauri::command]
pub async fn update_todo(todo: Todo, state: tauri::State<'_, AppState>) -> Result<(), String> {
    if let Some((todos, _)) = &mut *state.todos.lock().await {
        todos
            .update(todo.id, todo.label)
            .await
            .map_err(|e| e.to_string())?;
        return Ok(());
    }
    Err("not initialized".to_string())
}

#[tauri::command]
pub async fn toggle_done(id: String, state: tauri::State<'_, AppState>) -> Result<bool, String> {
    if let Some((todos, _)) = &mut *state.todos.lock().await {
        todos.toggle_done(id).await.map_err(|e| e.to_string())?;
        return Ok(true);
    }
    Err("not initialized".to_string())
}

#[tauri::command]
pub async fn delete(id: String, state: tauri::State<'_, AppState>) -> Result<bool, String> {
    if let Some((todos, _)) = &mut *state.todos.lock().await {
        todos.delete(id).await.map_err(|e| e.to_string())?;
        return Ok(true);
    }
    Err("not initialized".to_string())
}

#[tauri::command]
pub async fn set_ticket(
    app_handle: tauri::AppHandle,
    ticket: String,
    state: tauri::State<'_, AppState>,
) -> Result<(), String> {
    let todos = Todos::new(Some(ticket), state.iroh().clone())
        .await
        .map_err(|e| e.to_string())?;

    state
        .init_todos(app_handle, todos)
        .await
        .map_err(|e| e.to_string())?;

    Ok(())
}

#[tauri::command]
pub async fn get_ticket(state: tauri::State<'_, AppState>) -> Result<String, String> {
    if let Some((todos, _)) = &mut *state.todos.lock().await {
        return Ok(todos.ticket());
    }
    Err("not initialized".to_string())
}

================
File: tauri-todos/src-tauri/src/iroh.rs
================
use std::{path::PathBuf, sync::Arc};

use anyhow::Result;
use iroh::protocol::Router;
use quic_rpc::transport::flume::FlumeConnector;

pub(crate) type BlobsClient = iroh_blobs::rpc::client::blobs::Client<
    FlumeConnector<iroh_blobs::rpc::proto::Response, iroh_blobs::rpc::proto::Request>,
>;
pub(crate) type DocsClient = iroh_docs::rpc::client::docs::Client<
    FlumeConnector<iroh_docs::rpc::proto::Response, iroh_docs::rpc::proto::Request>,
>;

#[derive(Clone, Debug)]
pub(crate) struct Iroh {
    #[allow(dead_code)]
    router: Router,
    pub(crate) blobs: BlobsClient,
    pub(crate) docs: DocsClient,
}

impl Iroh {
    pub async fn new(path: PathBuf) -> Result<Self> {
        // create dir if it doesn't already exist
        tokio::fs::create_dir_all(&path).await?;

        let key = iroh_blobs::util::fs::load_secret_key(path.clone().join("keypair")).await?;

        // create endpoint
        let endpoint = iroh::Endpoint::builder()
            .discovery_n0()
            .secret_key(key)
            .bind()
            .await?;

        // build the protocol router
        let mut builder = iroh::protocol::Router::builder(endpoint);

        // add iroh gossip
        let gossip = iroh_gossip::net::Gossip::builder()
            .spawn(builder.endpoint().clone())
            .await?;
        builder = builder.accept(iroh_gossip::ALPN, Arc::new(gossip.clone()));

        // add iroh blobs
        let blobs = iroh_blobs::net_protocol::Blobs::persistent(&path)
            .await?
            .build(builder.endpoint());
        builder = builder.accept(iroh_blobs::ALPN, blobs.clone());

        // add docs
        let docs = iroh_docs::protocol::Docs::persistent(path)
            .spawn(&blobs, &gossip)
            .await?;
        builder = builder.accept(iroh_docs::ALPN, Arc::new(docs.clone()));

        let router = builder.spawn();

        let blobs_client = blobs.client().clone();
        let docs_client = docs.client().clone();

        Ok(Self {
            router,
            blobs: blobs_client,
            docs: docs_client,
        })
    }

    #[allow(dead_code)]
    pub(crate) async fn shutdown(self) -> Result<()> {
        self.router.shutdown().await
    }
}

================
File: tauri-todos/src-tauri/src/lib.rs
================
mod ipc;
mod iroh;
mod state;
mod todos;

use anyhow::{anyhow, Result};
use state::AppState;
use tauri::Manager as _;

use self::iroh::Iroh;

// setup an iroh node
async fn setup<R: tauri::Runtime>(handle: tauri::AppHandle<R>) -> Result<()> {
    // get the applicaiton data root, join with "iroh_data" to get the data root for the iroh node
    let data_root = handle
        .path()
        .app_data_dir()
        .map_err(|_| anyhow!("can't get application data directory"))?
        .join("iroh_data");

    let iroh = Iroh::new(data_root).await?;
    handle.manage(AppState::new(iroh));

    Ok(())
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .setup(|app| {
            #[cfg(debug_assertions)] // only include this code on debug builds
            app.get_webview_window("main").unwrap().open_devtools();
            let handle = app.handle().clone();

            tauri::async_runtime::spawn(async move {
                println!("starting backend...");
                if let Err(err) = setup(handle).await {
                    eprintln!("failed: {:?}", err);
                }
            });

            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            ipc::new_list,
            ipc::get_ticket,
            ipc::get_todos,
            ipc::new_todo,
            ipc::toggle_done,
            ipc::update_todo,
            ipc::delete,
            ipc::set_ticket,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

================
File: tauri-todos/src-tauri/src/main.rs
================
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    tauri_todomvc_lib::run()
}

================
File: tauri-todos/src-tauri/src/state.rs
================
use anyhow::Result;
use futures_lite::StreamExt;
use iroh_docs::{rpc::client::docs::LiveEvent, ContentStatus};
use tauri::Emitter as _;
use tokio::sync::Mutex;

use crate::{todos::Todos, Iroh};

pub struct AppState {
    pub todos: Mutex<Option<(Todos, tokio::task::JoinHandle<()>)>>,
    iroh: Iroh,
}
impl AppState {
    pub fn new(iroh: Iroh) -> Self {
        AppState {
            todos: Mutex::new(None),
            iroh,
        }
    }

    pub fn iroh(&self) -> &Iroh {
        &self.iroh
    }

    pub async fn init_todos<R: tauri::Runtime>(
        &self,
        app_handle: tauri::AppHandle<R>,
        todos: Todos,
    ) -> Result<()> {
        let mut events = todos.doc_subscribe().await?;
        let events_handle = tokio::spawn(async move {
            while let Some(Ok(event)) = events.next().await {
                match event {
                    LiveEvent::InsertRemote { content_status, .. } => {
                        // Only update if the we already have the content. Likely to happen when a remote user toggles "done".
                        if content_status == ContentStatus::Complete {
                            app_handle.emit("update-all", ()).ok();
                        }
                    }
                    LiveEvent::InsertLocal { .. } | LiveEvent::ContentReady { .. } => {
                        app_handle.emit("update-all", ()).ok();
                    }
                    _ => {}
                }
            }
        });

        let mut t = self.todos.lock().await;
        if let Some((_t, handle)) = t.take() {
            handle.abort();
        }
        *t = Some((todos, events_handle));

        Ok(())
    }
}

================
File: tauri-todos/src-tauri/src/todos.rs
================
use std::str::FromStr;

use anyhow::{bail, ensure, Context, Result};
use bytes::Bytes;
use futures_lite::{Stream, StreamExt};
use iroh_docs::rpc::client::docs::Doc;
use iroh_docs::rpc::client::docs::{Entry, LiveEvent, ShareMode};
use iroh_docs::{store::Query, AuthorId, DocTicket};

use quic_rpc::transport::flume::FlumeConnector;
// use iroh::ticket::DocTicket;
use serde::{Deserialize, Serialize};

use super::iroh::Iroh;

/// Todo in a list of todos.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Todo {
    /// String id
    pub id: String,
    /// Description of the todo
    /// Limited to 2000 characters
    pub label: String,
    /// Record creation timestamp. Counted as micros since the Unix epoch.
    pub created: u64,
    /// Whether or not the todo has been completed. Done todos will show up in the todo list until
    /// they are archived.
    pub done: bool,
    /// Indicates whether or not the todo is tombstoned
    pub is_delete: bool,
}

impl Todo {
    fn from_bytes(bytes: Bytes) -> anyhow::Result<Self> {
        let todo = serde_json::from_slice(&bytes).context("invalid json")?;
        Ok(todo)
    }

    fn as_bytes(&self) -> anyhow::Result<Bytes> {
        let buf = serde_json::to_vec(self)?;
        ensure!(buf.len() < MAX_TODO_SIZE, "todo too large");
        Ok(buf.into())
    }

    fn missing_todo(id: String) -> Self {
        Self {
            label: String::from("Missing Content"),
            created: 0,
            done: false,
            is_delete: false,
            id,
        }
    }
}

const MAX_TODO_SIZE: usize = 2 * 1024;
const MAX_LABEL_LEN: usize = 2 * 1000;

/// List of todos, including completed todos that have not been archived
pub struct Todos {
    iroh: Iroh,
    doc: Doc<FlumeConnector<iroh_docs::rpc::proto::Response, iroh_docs::rpc::proto::Request>>,

    ticket: DocTicket,
    author: AuthorId,
}

impl Todos {
    pub async fn new(ticket: Option<String>, iroh: Iroh) -> anyhow::Result<Self> {
        let author = iroh.docs.authors().create().await?;

        let doc = match ticket {
            None => iroh.docs.create().await?,
            Some(ticket) => {
                let ticket = DocTicket::from_str(&ticket)?;
                iroh.docs.import(ticket).await?
            }
        };

        let ticket = doc.share(ShareMode::Write, Default::default()).await?;

        Ok(Todos {
            iroh,
            author,
            doc,
            ticket,
        })
    }

    pub fn ticket(&self) -> String {
        self.ticket.to_string()
    }

    pub async fn doc_subscribe(&self) -> Result<impl Stream<Item = Result<LiveEvent>> + use<>> {
        self.doc.subscribe().await
    }

    pub async fn add(&mut self, id: String, label: String) -> anyhow::Result<()> {
        if label.len() > MAX_LABEL_LEN {
            bail!("label is too long, max size is {MAX_LABEL_LEN} characters");
        }
        let created = std::time::SystemTime::now()
            .duration_since(std::time::SystemTime::UNIX_EPOCH)
            .expect("time drift")
            .as_secs();
        let todo = Todo {
            label,
            created,
            done: false,
            is_delete: false,
            id: id.clone(),
        };
        self.insert_bytes(id.as_bytes(), todo.as_bytes()?).await
    }

    pub async fn toggle_done(&mut self, id: String) -> anyhow::Result<()> {
        let mut todo = self.get_todo(id.clone()).await?;
        todo.done = !todo.done;
        self.update_todo(id.as_bytes(), todo).await
    }

    pub async fn delete(&mut self, id: String) -> anyhow::Result<()> {
        let mut todo = self.get_todo(id.clone()).await?;
        todo.is_delete = true;
        self.update_todo(id.as_bytes(), todo).await
    }

    pub async fn update(&mut self, id: String, label: String) -> anyhow::Result<()> {
        if label.len() >= MAX_LABEL_LEN {
            bail!("label is too long, must be {MAX_LABEL_LEN} or shorter");
        }
        let mut todo = self.get_todo(id.clone()).await?;
        todo.label = label;
        self.update_todo(id.as_bytes(), todo).await
    }

    pub async fn get_todos(&self) -> anyhow::Result<Vec<Todo>> {
        let mut entries = self.doc.get_many(Query::single_latest_per_key()).await?;

        let mut todos = Vec::new();
        while let Some(entry) = entries.next().await {
            let entry = entry?;
            let todo = self.todo_from_entry(&entry).await?;
            if !todo.is_delete {
                todos.push(todo);
            }
        }
        todos.sort_by_key(|t| t.created);
        Ok(todos)
    }

    async fn insert_bytes(&self, key: impl AsRef<[u8]>, content: Bytes) -> anyhow::Result<()> {
        self.doc
            .set_bytes(self.author, key.as_ref().to_vec(), content)
            .await?;
        Ok(())
    }

    async fn update_todo(&mut self, key: impl AsRef<[u8]>, todo: Todo) -> anyhow::Result<()> {
        let content = todo.as_bytes()?;
        self.insert_bytes(key, content).await
    }

    async fn get_todo(&self, id: String) -> anyhow::Result<Todo> {
        let entry = self
            .doc
            .get_many(Query::single_latest_per_key().key_exact(id))
            .await?
            .next()
            .await
            .ok_or_else(|| anyhow::anyhow!("no todo found"))??;

        self.todo_from_entry(&entry).await
    }

    async fn todo_from_entry(&self, entry: &Entry) -> anyhow::Result<Todo> {
        let id = String::from_utf8(entry.key().to_owned()).context("invalid key")?;
        match self.iroh.blobs.read_to_bytes(entry.content_hash()).await {
            Ok(b) => Todo::from_bytes(b),
            Err(_) => Ok(Todo::missing_todo(id)),
        }
    }
}

================
File: tauri-todos/src-tauri/.gitignore
================
# Generated by Cargo
# will have compiled files and executables
/target/

# Generated by Tauri
# will have schema files for capabilities auto-completion
/gen/schemas

================
File: tauri-todos/src-tauri/build.rs
================
fn main() {
    tauri_build::build()
}

================
File: tauri-todos/src-tauri/Cargo.toml
================
[package]
name = "tauri-todomvc"
version = "0.1.0"
description = "Todos with Iroh"
license = "MIT OR Apache-2.0"
authors = ["dignifiedquire <me@dignifiedquire.com>", "n0 team"]
repository = "https://github.com/n0-computer/iroh-example-todos"
edition = "2024"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
# The `_lib` suffix may seem redundant but it is necessary
# to make the lib name unique and wouldn't conflict with the bin name.
# This seems to be only an issue on Windows, see https://github.com/rust-lang/cargo/issues/8519
name = "tauri_todomvc_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "^2", features = [] }

[dependencies]
tauri = { version = "^2", features = [] }
tauri-plugin-opener = "^2"
serde = { version = "^1", features = ["derive"] }
serde_json = "^1"
anyhow = "^1"
tokio = { version = "1" }
quic-rpc = { version = "0.20" }
iroh = "0.35"
iroh-docs = { version = "0.35", features = ["rpc"] }
iroh-blobs = { version = "0.35", features = ["rpc"] }
iroh-gossip = { version = "0.35", features = ["rpc"] }
iroh-node-util = "0.35"
bytes = "1"
num_cpus = { version = "1.15.0" }
tokio-util = { version = "0.7" }
futures-lite = "2.3.0"

[profile.release]
panic = "abort"   # Strip expensive panic clean-up logic
codegen-units = 1 # Compile crates one after another so the compiler can optimize better
lto = true        # Enables link to optimizations
opt-level = "s"   # Optimize for binary size
strip = true      # Remove debug symbols

================
File: tauri-todos/src-tauri/tauri.conf.json
================
{
  "$schema": "https://schema.tauri.app/config/2",
  "productName": "tauri-todomvc",
  "version": "0.1.0",
  "identifier": "com.tauri-todomvc.app",
  "build": {
    "beforeDevCommand": "npm run dev",
    "devUrl": "http://localhost:1420",
    "beforeBuildCommand": "npm run build",
    "frontendDist": "../dist"
  },
  "app": {
    "windows": [
      {
        "title": "Todo-mvc",
        "width": 800,
        "height": 600,
        "resizable": true,
        "fullscreen": false
      }
    ],
    "security": {
      "csp": null
    }
  },
  "bundle": {
    "active": true,
    "targets": "all",
    "category": "DeveloperTool",
    "shortDescription": "",
    "longDescription": "",
    "icon": [
      "icons/32x32.png", 
      "icons/128x128.png", 
      "icons/128x128@2x.png", 
      "icons/icon.icns", 
      "icons/icon.ico"
    ]
  }
}

================
File: tauri-todos/.gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*
*db.sqlite

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
*.sqlite

================
File: tauri-todos/index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/src/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Todo App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: tauri-todos/LICENSE-APACHE
================
Apache License
                        Version 2.0, January 2004
                     http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.

   "License" shall mean the terms and conditions for use, reproduction,
   and distribution as defined by Sections 1 through 9 of this document.

   "Licensor" shall mean the copyright owner or entity authorized by
   the copyright owner that is granting the License.

   "Legal Entity" shall mean the union of the acting entity and all
   other entities that control, are controlled by, or are under common
   control with that entity. For the purposes of this definition,
   "control" means (i) the power, direct or indirect, to cause the
   direction or management of such entity, whether by contract or
   otherwise, or (ii) ownership of fifty percent (50%) or more of the
   outstanding shares, or (iii) beneficial ownership of such entity.

   "You" (or "Your") shall mean an individual or Legal Entity
   exercising permissions granted by this License.

   "Source" form shall mean the preferred form for making modifications,
   including but not limited to software source code, documentation
   source, and configuration files.

   "Object" form shall mean any form resulting from mechanical
   transformation or translation of a Source form, including but
   not limited to compiled object code, generated documentation,
   and conversions to other media types.

   "Work" shall mean the work of authorship, whether in Source or
   Object form, made available under the License, as indicated by a
   copyright notice that is included in or attached to the work
   (an example is provided in the Appendix below).

   "Derivative Works" shall mean any work, whether in Source or Object
   form, that is based on (or derived from) the Work and for which the
   editorial revisions, annotations, elaborations, or other modifications
   represent, as a whole, an original work of authorship. For the purposes
   of this License, Derivative Works shall not include works that remain
   separable from, or merely link (or bind by name) to the interfaces of,
   the Work and Derivative Works thereof.

   "Contribution" shall mean any work of authorship, including
   the original version of the Work and any modifications or additions
   to that Work or Derivative Works thereof, that is intentionally
   submitted to Licensor for inclusion in the Work by the copyright owner
   or by an individual or Legal Entity authorized to submit on behalf of
   the copyright owner. For the purposes of this definition, "submitted"
   means any form of electronic, verbal, or written communication sent
   to the Licensor or its representatives, including but not limited to
   communication on electronic mailing lists, source code control systems,
   and issue tracking systems that are managed by, or on behalf of, the
   Licensor for the purpose of discussing and improving the Work, but
   excluding communication that is conspicuously marked or otherwise
   designated in writing by the copyright owner as "Not a Contribution."

   "Contributor" shall mean Licensor and any individual or Legal Entity
   on behalf of whom a Contribution has been received by Licensor and
   subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   copyright license to reproduce, prepare Derivative Works of,
   publicly display, publicly perform, sublicense, and distribute the
   Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of
   this License, each Contributor hereby grants to You a perpetual,
   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
   (except as stated in this section) patent license to make, have made,
   use, offer to sell, sell, import, and otherwise transfer the Work,
   where such license applies only to those patent claims licensable
   by such Contributor that are necessarily infringed by their
   Contribution(s) alone or by combination of their Contribution(s)
   with the Work to which such Contribution(s) was submitted. If You
   institute patent litigation against any entity (including a
   cross-claim or counterclaim in a lawsuit) alleging that the Work
   or a Contribution incorporated within the Work constitutes direct
   or contributory patent infringement, then any patent licenses
   granted to You under this License for that Work shall terminate
   as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the
   Work or Derivative Works thereof in any medium, with or without
   modifications, and in Source or Object form, provided that You
   meet the following conditions:

   (a) You must give any other recipients of the Work or
       Derivative Works a copy of this License; and

   (b) You must cause any modified files to carry prominent notices
       stating that You changed the files; and

   (c) You must retain, in the Source form of any Derivative Works
       that You distribute, all copyright, patent, trademark, and
       attribution notices from the Source form of the Work,
       excluding those notices that do not pertain to any part of
       the Derivative Works; and

   (d) If the Work includes a "NOTICE" text file as part of its
       distribution, then any Derivative Works that You distribute must
       include a readable copy of the attribution notices contained
       within such NOTICE file, excluding those notices that do not
       pertain to any part of the Derivative Works, in at least one
       of the following places: within a NOTICE text file distributed
       as part of the Derivative Works; within the Source form or
       documentation, if provided along with the Derivative Works; or,
       within a display generated by the Derivative Works, if and
       wherever such third-party notices normally appear. The contents
       of the NOTICE file are for informational purposes only and
       do not modify the License. You may add Your own attribution
       notices within Derivative Works that You distribute, alongside
       or as an addendum to the NOTICE text from the Work, provided
       that such additional attribution notices cannot be construed
       as modifying the License.

   You may add Your own copyright statement to Your modifications and
   may provide additional or different license terms and conditions
   for use, reproduction, or distribution of Your modifications, or
   for any such Derivative Works as a whole, provided Your use,
   reproduction, and distribution of the Work otherwise complies with
   the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise,
   any Contribution intentionally submitted for inclusion in the Work
   by You to the Licensor shall be under the terms and conditions of
   this License, without any additional terms or conditions.
   Notwithstanding the above, nothing herein shall supersede or modify
   the terms of any separate license agreement you may have executed
   with Licensor regarding such Contributions.

6. Trademarks. This License does not grant permission to use the trade
   names, trademarks, service marks, or product names of the Licensor,
   except as required for reasonable and customary use in describing the
   origin of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or
   agreed to in writing, Licensor provides the Work (and each
   Contributor provides its Contributions) on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
   implied, including, without limitation, any warranties or conditions
   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
   PARTICULAR PURPOSE. You are solely responsible for determining the
   appropriateness of using or redistributing the Work and assume any
   risks associated with Your exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory,
   whether in tort (including negligence), contract, or otherwise,
   unless required by applicable law (such as deliberate and grossly
   negligent acts) or agreed to in writing, shall any Contributor be
   liable to You for damages, including any direct, indirect, special,
   incidental, or consequential damages of any character arising as a
   result of this License or out of the use or inability to use the
   Work (including but not limited to damages for loss of goodwill,
   work stoppage, computer failure or malfunction, or any and all
   other commercial damages or losses), even if such Contributor
   has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing
   the Work or Derivative Works thereof, You may choose to offer,
   and charge a fee for, acceptance of support, warranty, indemnity,
   or other liability obligations and/or rights consistent with this
   License. However, in accepting such obligations, You may act only
   on Your own behalf and on Your sole responsibility, not on behalf
   of any other Contributor, and only if You agree to indemnify,
   defend, and hold each Contributor harmless for any liability
   incurred by, or claims asserted against, such Contributor by reason
   of your accepting any such warranty or additional liability.

END OF TERMS AND CONDITIONS

APPENDIX: How to apply the Apache License to your work.

   To apply the Apache License to your work, attach the following
   boilerplate notice, with the fields enclosed by brackets "[]"
   replaced with your own identifying information. (Don't include
   the brackets!)  The text should be enclosed in the appropriate
   comment syntax for the file format. We also recommend that a
   file or class name and description of purpose be included on the
   same "printed page" as the copyright notice for easier
   identification within third-party archives.

Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

================
File: tauri-todos/LICENSE-MIT
================
Copyright 2023 N0, INC.

Permission is hereby granted, free of charge, to any
person obtaining a copy of this software and associated
documentation files (the "Software"), to deal in the
Software without restriction, including without
limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice
shall be included in all copies or substantial portions
of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

================
File: tauri-todos/package.json
================
{
  "name": "iroh-tauri-todomvc",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "tauri": "tauri"
  },
  "dependencies": {
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "@tauri-apps/api": "^2",
    "jotai": "^2.2.3",
    "react-use": "^17.4.0",
    "reactjs-popup": "^2.0.5",
    "todomvc-app-css": "^2.4.2",
    "use-debounce": "^10.0.0",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@types/react": "^19.1.6",
    "@types/react-dom": "^19.1.5",
    "@vitejs/plugin-react": "^4.3.4",
    "typescript": "*",
    "vite": "^6.0.3",
    "@tauri-apps/cli": "^2"
  }
}

================
File: tauri-todos/README.md
================
# iroh-tauri-todomvc

This TODO app was created as an example for how to use Iroh to add sync and
networking capabilities to your app.

If you have any specific capabilities you would like to see demonstrated in
this app, please add an issue, with the "feature request" tag.

## tauri-todomvc

The original tauri & todomvc code can be found at
[tauri-todomvc](https://github.com/enpitsuLin/tauri-todomvc/tree/master).

## Development

Requirement:

- Rust
- NodeJS
- webkit2gtk

install dependencies:

```sh
npm i
```

Then run tauri

```sh
npm run tauri dev
```


# License

Copyright 2023 N0, INC.

This project is licensed under either of

 * Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or
   http://www.apache.org/licenses/LICENSE-2.0)
 * MIT license ([LICENSE-MIT](LICENSE-MIT) or
   http://opensource.org/licenses/MIT)

at your option.

### Contribution

Unless you explicitly state otherwise, any contribution intentionally submitted
for inclusion in this project by you, as defined in the Apache-2.0 license,
shall be dual licensed as above, without any additional terms or conditions.

================
File: tauri-todos/tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

================
File: tauri-todos/tsconfig.node.json
================
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: tauri-todos/vite.config.ts
================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// @ts-expect-error process is a nodejs global
const host = process.env.TAURI_DEV_HOST;

// https://vitejs.dev/config/
export default defineConfig(async () => ({
  plugins: [react()],

  // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
  //
  // 1. prevent vite from obscuring rust errors
  clearScreen: false,
  // 2. tauri expects a fixed port, fail if that port is not available
  server: {
    port: 1420,
    strictPort: true,
    host: host || false,
    hmr: host
      ? {
          protocol: "ws",
          host,
          port: 1421,
        }
      : undefined,
    watch: {
      // 3. tell vite to ignore watching `src-tauri`
      ignored: ["**/src-tauri/**"],
    },
  },
}));

================
File: .gitignore
================
target/
*iroh-data
*/.sendme*
/deploy-out

================
File: Makefile.toml
================
# Use cargo-make to run tasks here: https://crates.io/crates/cargo-make

# this task is run from the "deploy" workflow in .github/workflows/deploy
# it builds all browser examples, and assembles them in a deploy-out directory
# together with a simple index.html with links to the individual examples.
[tasks.deploy]
dependencies = [
    { name = "deploy", path = "browser-echo" },
    { name = "deploy", path = "browser-chat" },
]

script = '''
rm -r deploy-out || true
mkdir deploy-out

cat <<EOF > deploy-out/index.html
<!DOCTYPE html>
<html lang="en"><head><title>iroh examples</title></head>
<body><h1>iroh examples</h1><a href="https://github.com/n0-computer/iroh-examples">source code</a><ul>
EOF

cp -r browser-echo/public deploy-out/browser-echo
echo '<li><a href="./browser-echo/index.html">browser-echo</li>' >> deploy-out/index.html

cp -r browser-chat/frontend/dist deploy-out/browser-chat
echo '<li><a href="./browser-chat/index.html">browser-chat</li>' >> deploy-out/index.html

echo '</ul></body></html>' >> deploy-out/index.html
'''

================
File: README.md
================
# Iroh-Examples

Examples how to use iroh or one of the iroh library crates.
Things in here should be somewhat easy to understand.

For very experimental things there is [iroh-experiments].

## Examples

### [browser-echo](browser-echo)

Use iroh in the browser, compiled to web assembly. [Try it here!](https://n0-computer.github.io/iroh-examples/main/browser-echo/index.html)

### [browser-chat](browser-chat)

A chat app based on iroh-gossip that can run both in the browser and on the command line.
[Try it here!](https://n0-computer.github.io/iroh-examples/main/browser-chat/index.html)

### [dumbpipe-web](dumbpipe-web)

Forward http requests to dumbpipe. Share a local dev server publicly.

### [extism](extism)

Use iroh through [extism]

### [framed messages](framed-messages)

Send chess moves back and forth on the same bi-directional stream by framing it using `tokio-util`'s `codec` feature.

### [frosty](frosty)

Experiment with [FROST] threshold signatures for iroh.

### [iroh-automerge](iroh-automerge)

Iroh integration with [automerge]

### [iroh-gateway](iroh-gateway)

A http gateway for iroh-blobs data, written using iroh-blobs.

### [tauri-todos](tauri-todos)

Todo app using iroh documents and [tauri].


[iroh-experiments]: https://github.com/n0-computer/iroh-experiments
[extism]: https://extism.org/
[automerge]: https://automerge.org/
[mainline]: https://en.wikipedia.org/wiki/Mainline_DHT
[pkarr]: https://pkarr.org/
[tauri]: https://tauri.app/
[FROST]: https://eprint.iacr.org/2020/852.pdf



================================================================
End of Codebase
================================================================
