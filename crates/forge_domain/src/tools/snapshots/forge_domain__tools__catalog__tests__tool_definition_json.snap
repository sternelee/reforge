---
source: crates/forge_domain/src/tools/catalog.rs
expression: tools
---
{
  "title": "FSRead",
  "type": "object",
  "properties": {
    "end_line": {
      "description": "The line number to stop reading at (inclusive). Only provide if the file\nis too large to read at once",
      "type": "integer",
      "format": "int32",
      "nullable": true
    },
    "file_path": {
      "description": "The absolute path to the file to read",
      "type": "string"
    },
    "show_line_numbers": {
      "description": "If true, prefixes each line with its line index (starting at 1).\nDefaults to true.",
      "type": "boolean",
      "default": true
    },
    "start_line": {
      "description": "The line number to start reading from starting from 1 not 0. Only\nprovide if the file is too large to read at once",
      "type": "integer",
      "format": "int32",
      "nullable": true
    }
  },
  "required": [
    "file_path"
  ]
}
{
  "title": "FSWrite",
  "type": "object",
  "properties": {
    "content": {
      "description": "The content to write to the file",
      "type": "string"
    },
    "file_path": {
      "description": "The absolute path to the file to write (must be absolute, not relative)",
      "type": "string"
    },
    "overwrite": {
      "description": "If set to true, existing files will be overwritten. If not set and the\nfile exists, an error will be returned with the content of the\nexisting file.",
      "type": "boolean"
    }
  },
  "required": [
    "file_path",
    "content"
  ]
}
{
  "title": "FSSearch",
  "type": "object",
  "properties": {
    "-A": {
      "description": "Number of lines to show after each match (rg -A). Requires output_mode:\n\"content\", ignored otherwise.",
      "type": "integer",
      "format": "uint32",
      "minimum": 0,
      "nullable": true
    },
    "-B": {
      "description": "Number of lines to show before each match (rg -B). Requires output_mode:\n\"content\", ignored otherwise.",
      "type": "integer",
      "format": "uint32",
      "minimum": 0,
      "nullable": true
    },
    "-C": {
      "description": "Number of lines to show before and after each match (rg -C). Requires\noutput_mode: \"content\", ignored otherwise.",
      "type": "integer",
      "format": "uint32",
      "minimum": 0,
      "nullable": true
    },
    "-i": {
      "description": "Case insensitive search (rg -i)",
      "type": "boolean",
      "nullable": true
    },
    "-n": {
      "description": "Show line numbers in output (rg -n). Requires output_mode: \"content\",\nignored otherwise.",
      "type": "boolean",
      "nullable": true
    },
    "glob": {
      "description": "Glob pattern to filter files (e.g. \"*.js\", \"*.{ts,tsx}\") - maps to rg\n--glob",
      "type": "string",
      "nullable": true
    },
    "head_limit": {
      "description": "Limit output to first N lines/entries, equivalent to \"| head -N\". Works\nacross all output modes: content (limits output lines),\nfiles_with_matches (limits file paths), count (limits count entries).\nWhen unspecified, shows all results from ripgrep.",
      "type": "integer",
      "format": "uint32",
      "minimum": 0,
      "nullable": true
    },
    "multiline": {
      "description": "Enable multiline mode where . matches newlines and patterns can span\nlines (rg -U --multiline-dotall). Default: false.",
      "type": "boolean",
      "nullable": true
    },
    "offset": {
      "description": "Skip first N lines/entries before applying head_limit",
      "type": "integer",
      "format": "uint32",
      "minimum": 0,
      "nullable": true
    },
    "output_mode": {
      "description": "Output mode: \"content\" shows matching lines (supports -A/-B/-C context,\n-n line numbers, head_limit), \"files_with_matches\" shows file paths\n(supports head_limit), \"count\" shows match counts (supports head_limit).\nDefaults to \"files_with_matches\".",
      "type": "string",
      "enum": [
        "content",
        "files_with_matches",
        "count",
        null
      ],
      "nullable": true
    },
    "path": {
      "description": "File or directory to search in (rg PATH). Defaults to current working\ndirectory.",
      "type": "string",
      "nullable": true
    },
    "pattern": {
      "description": "The regular expression pattern to search for in file contents.",
      "type": "string"
    },
    "type": {
      "description": "File type to search (rg --type). Common types: js, py, rust, go, java,\netc. More efficient than include for standard file types.",
      "type": "string",
      "nullable": true
    }
  },
  "required": [
    "pattern"
  ]
}
{
  "title": "SemanticSearch",
  "type": "object",
  "properties": {
    "queries": {
      "description": "List of search queries to execute in parallel. Using multiple queries\n(2-3) with varied phrasings significantly improves results - each query\ncaptures different aspects of what you're looking for. Each query pairs\na search term with a use_case for reranking. Example: for\nauthentication, try \"user login verification\", \"token generation\",\n\"OAuth flow\".",
      "type": "array",
      "items": {
        "description": "A paired query and use_case for semantic search. Each query must have a\ncorresponding use_case for document reranking.",
        "type": "object",
        "properties": {
          "query": {
            "description": "The semantic embedding query that describes WHAT the code does or its\npurpose. This query is converted to a vector embedding and used to find\nsemantically similar code chunks in the vector database.\n\n**Guidelines for effective embedding queries:**\n- Use specific, targeted technical terms and domain concepts\n- Describe behavior, functionality, patterns, or implementation approach\n- Include concrete keywords like technology names, algorithms, data\n  structures\n- Balance specificity (focused results) with generality (avoid missing\n  relevant code)\n- Keep queries focused - overly broad queries cause timeouts and poor\n  results\n- **Align keywords with intent**: For documentation, use \"README\",\n  \"guide\", \"setup\"; for implementation, use \"function\", \"logic\",\n  \"handler\"\n\n**Good examples:**\n- \"exponential backoff retry mechanism with configurable delays\"\n- \"streaming LLM responses with SSE chunked transfer encoding\"\n- \"OAuth2 token refresh with automatic retry and expiry check\"\n- \"Diesel database migration runner with transaction support\"\n- \"semantic search reranker using cross-encoder model\"\n- \"README documentation configuration setup semantic search\"\n- \"markdown guide API documentation tool definitions\"\n\n**Bad examples:**\n- \"retry\" (too generic, will match everything)\n- \"authentication\" (overly broad - specify what aspect: login, tokens,\n  middleware?)\n- \"tool definitions schemas\" (too vague - be more specific about\n  structure or location)\n- \"how system works\" (meta-question, not searchable concept)\n- \"function that validates\" (focus on what it validates, not that it's a\n  function)",
            "type": "string"
          },
          "use_case": {
            "description": "The reranking query that describes your INTENT and WHY you need this\ncode. This query is used by the reranker model to filter and\nprioritize the most relevant results from the initial embedding\nsearch based on your specific use case.\n\n**Purpose:** While `query` casts a wide net for similar code, `use_case`\nnarrows it down by intent: implementation vs docs vs tests, reading\nvs modifying code, understanding architecture vs finding bugs, etc.\n\n**Guidelines for effective reranking queries:**\n- **MANDATORY FOR CODE**: ALWAYS include codebase construct keywords\n  (struct, trait, impl, interface, class, function, fn, definition,\n  implementation, declaration, type) when searching for code\n- **WHY CRITICAL**: The reranker gives HIGH WEIGHTAGE to these keywords\n  - \"struct\" → prioritizes struct definitions\n  - \"trait impl\" → prioritizes trait implementations\n  - \"function\" / \"fn\" → prioritizes function definitions\n  - Without these, you get documentation instead of code!\n- Clearly state your goal: understand, modify, debug, find examples,\n  etc.\n- Specify the TYPE of code you need: implementation, tests, docs,\n  config, architecture\n- Include WHY context: \"to fix a bug\", \"to add a feature\", \"to\n  understand flow\"\n- Be explicit about what to AVOID: \"not tests\", \"not documentation\",\n  \"not examples\"\n- **Match intent to file types**: documentation intent → avoid\n  requesting \"implementation code\"; implementation intent → avoid\n  requesting \"documentation\"\n- Keep it concise (1-2 sentences) but informative\n- MUST be different from the embedding query - add intent/context\n\n**Good examples (ALWAYS include construct keywords):**\n- \"I need the struct definition and trait implementation for Diesel\n  migrations to understand the transaction handling, not setup docs\"\n- \"Show me the function implementation for semantic search reranker so I\n  can modify it to support file type filtering\"\n- \"Find the type declarations and interface definitions for the tool\n  registry, not the usage examples\"\n- \"I'm debugging a timeout issue and need the function implementation\n  that handles streaming responses, not the API documentation\"\n- \"Show me the struct definitions and trait implementations for\n  authentication, not the setup guide\"\n- \"I need the impl block for workspace sync to understand how it detects\n  file changes\"\n- \"Find the fn definitions for embedding generation batching logic\"\n- \"I need documentation explaining how to configure semantic search, not\n  the implementation code\"\n- \"Find the README or setup guide that explains the tool registration\n  process, avoiding implementation details\"\n\n**Bad examples (missing construct keywords = FAILS):**\n- \"I need code that handles authentication\" ❌ MISSING:\n  struct/trait/impl/function\n- \"Show me the database logic\" ❌ MISSING: trait/impl/function keywords\n- \"I need the workspace sync implementation\" ❌ MISSING: struct/impl/fn\n  - too generic\n- \"Find the reranker code\" ❌ MISSING: struct/trait/impl/function\n- \"exponential backoff retry mechanism\" ❌ MISSING: WHY + construct\n  keywords\n- \"find authentication code\" ❌ MISSING: which construct? struct? trait?\n  impl?\n- \"tool definitions\" ❌ MISSING: struct? trait? type? be specific\n- \"how it works\" (too vague - specify what you want to understand)\n- Long rambling explanation without clear intent (keep it focused)",
            "type": "string"
          }
        },
        "required": [
          "query",
          "use_case"
        ]
      }
    }
  },
  "required": [
    "queries"
  ]
}
{
  "title": "FSRemove",
  "type": "object",
  "properties": {
    "path": {
      "description": "The path of the file to remove (absolute path required)",
      "type": "string"
    }
  },
  "required": [
    "path"
  ]
}
{
  "title": "FSPatch",
  "type": "object",
  "properties": {
    "file_path": {
      "description": "The absolute path to the file to modify",
      "type": "string"
    },
    "new_string": {
      "description": "The text to replace it with (must be different from old_string)",
      "type": "string"
    },
    "old_string": {
      "description": "The text to replace",
      "type": "string"
    },
    "replace_all": {
      "description": "Replace all occurrences of old_string (default false)",
      "type": "boolean",
      "default": false
    }
  },
  "required": [
    "file_path",
    "old_string",
    "new_string"
  ]
}
{
  "title": "FSUndo",
  "type": "object",
  "properties": {
    "path": {
      "description": "The absolute path of the file to revert to its previous state.",
      "type": "string"
    }
  },
  "required": [
    "path"
  ]
}
{
  "title": "Shell",
  "type": "object",
  "properties": {
    "command": {
      "description": "The shell command to execute.",
      "type": "string"
    },
    "cwd": {
      "description": "The working directory where the command should be executed.\nIf not specified, defaults to the current working directory from the\nenvironment.",
      "type": "string",
      "nullable": true
    },
    "description": {
      "description": "Clear, concise description of what this command does. Recommended to be\n5-10 words for simple commands. For complex commands with pipes or\nmultiple operations, provide more context. Examples: \"Lists files in\ncurrent directory\", \"Installs package dependencies\", \"Compiles Rust\nproject with release optimizations\".",
      "type": "string",
      "nullable": true
    },
    "env": {
      "description": "Environment variable names to pass to command execution (e.g., [\"PATH\",\n\"HOME\", \"USER\"]). The system automatically reads the specified\nvalues and applies them during command execution.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "nullable": true
    },
    "keep_ansi": {
      "description": "Whether to preserve ANSI escape codes in the output.\nIf true, ANSI escape codes will be preserved in the output.\nIf false (default), ANSI escape codes will be stripped from the output.",
      "type": "boolean"
    }
  },
  "required": [
    "command"
  ]
}
{
  "title": "NetFetch",
  "description": "Input type for the net fetch tool",
  "type": "object",
  "properties": {
    "raw": {
      "description": "Get raw content without any markdown conversion (default: false)",
      "type": "boolean",
      "nullable": true
    },
    "url": {
      "description": "URL to fetch",
      "type": "string"
    }
  },
  "required": [
    "url"
  ]
}
{
  "title": "Followup",
  "type": "object",
  "properties": {
    "multiple": {
      "description": "If true, allows selecting multiple options; if false (default), only one\noption can be selected",
      "type": "boolean",
      "nullable": true
    },
    "option1": {
      "description": "First option to choose from",
      "type": "string",
      "nullable": true
    },
    "option2": {
      "description": "Second option to choose from",
      "type": "string",
      "nullable": true
    },
    "option3": {
      "description": "Third option to choose from",
      "type": "string",
      "nullable": true
    },
    "option4": {
      "description": "Fourth option to choose from",
      "type": "string",
      "nullable": true
    },
    "option5": {
      "description": "Fifth option to choose from",
      "type": "string",
      "nullable": true
    },
    "question": {
      "description": "Question to ask the user",
      "type": "string"
    }
  },
  "required": [
    "question"
  ]
}
{
  "title": "PlanCreate",
  "type": "object",
  "properties": {
    "content": {
      "description": "The content to write to the plan file. This should be the complete\nplan content in markdown format.",
      "type": "string"
    },
    "plan_name": {
      "description": "The name of the plan (will be used in the filename)",
      "type": "string"
    },
    "version": {
      "description": "The version of the plan (e.g., \"v1\", \"v2\", \"1.0\")",
      "type": "string"
    }
  },
  "required": [
    "plan_name",
    "version",
    "content"
  ]
}
{
  "title": "SkillFetch",
  "type": "object",
  "properties": {
    "name": {
      "description": "The name of the skill to fetch (e.g., \"pdf\", \"code_review\")",
      "type": "string"
    }
  },
  "required": [
    "name"
  ]
}
