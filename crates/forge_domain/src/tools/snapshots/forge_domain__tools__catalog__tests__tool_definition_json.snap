---
source: crates/forge_domain/src/tools/catalog.rs
expression: tools
---
{
  "title": "FSRead",
  "type": "object",
  "required": [
    "file_path"
  ],
  "properties": {
    "end_line": {
      "description": "The line number to stop reading at (inclusive). Only provide if the file is too large to read at once",
      "type": "integer",
      "format": "int32",
      "nullable": true
    },
    "file_path": {
      "description": "The absolute path to the file to read",
      "type": "string"
    },
    "show_line_numbers": {
      "description": "If true, prefixes each line with its line index (starting at 1). Defaults to true.",
      "default": true,
      "type": "boolean"
    },
    "start_line": {
      "description": "The line number to start reading from starting from 1 not 0. Only provide if the file is too large to read at once",
      "type": "integer",
      "format": "int32",
      "nullable": true
    }
  }
}
{
  "title": "FSWrite",
  "type": "object",
  "required": [
    "content",
    "file_path"
  ],
  "properties": {
    "content": {
      "description": "The content to write to the file",
      "type": "string"
    },
    "file_path": {
      "description": "The absolute path to the file to write (must be absolute, not relative)",
      "type": "string"
    },
    "overwrite": {
      "description": "If set to true, existing files will be overwritten. If not set and the file exists, an error will be returned with the content of the existing file.",
      "type": "boolean"
    }
  }
}
{
  "title": "FSSearch",
  "type": "object",
  "required": [
    "pattern"
  ],
  "properties": {
    "-A": {
      "description": "Number of lines to show after each match (rg -A). Requires output_mode: \"content\", ignored otherwise.",
      "type": "integer",
      "format": "uint32",
      "minimum": 0.0,
      "nullable": true
    },
    "-B": {
      "description": "Number of lines to show before each match (rg -B). Requires output_mode: \"content\", ignored otherwise.",
      "type": "integer",
      "format": "uint32",
      "minimum": 0.0,
      "nullable": true
    },
    "-C": {
      "description": "Number of lines to show before and after each match (rg -C). Requires output_mode: \"content\", ignored otherwise.",
      "type": "integer",
      "format": "uint32",
      "minimum": 0.0,
      "nullable": true
    },
    "-i": {
      "description": "Case insensitive search (rg -i)",
      "type": "boolean",
      "nullable": true
    },
    "-n": {
      "description": "Show line numbers in output (rg -n). Requires output_mode: \"content\", ignored otherwise.",
      "type": "boolean",
      "nullable": true
    },
    "glob": {
      "description": "Glob pattern to filter files (e.g. \"*.js\", \"*.{ts,tsx}\") - maps to rg --glob",
      "type": "string",
      "nullable": true
    },
    "head_limit": {
      "description": "Limit output to first N lines/entries, equivalent to \"| head -N\". Works across all output modes: content (limits output lines), files_with_matches (limits file paths), count (limits count entries). When unspecified, shows all results from ripgrep.",
      "type": "integer",
      "format": "uint32",
      "minimum": 0.0,
      "nullable": true
    },
    "multiline": {
      "description": "Enable multiline mode where . matches newlines and patterns can span lines (rg -U --multiline-dotall). Default: false.",
      "type": "boolean",
      "nullable": true
    },
    "offset": {
      "description": "Skip first N lines/entries before applying head_limit",
      "type": "integer",
      "format": "uint32",
      "minimum": 0.0,
      "nullable": true
    },
    "output_mode": {
      "description": "Output mode: \"content\" shows matching lines (supports -A/-B/-C context, -n line numbers, head_limit), \"files_with_matches\" shows file paths (supports head_limit), \"count\" shows match counts (supports head_limit). Defaults to \"files_with_matches\".",
      "type": "string",
      "enum": [
        "content",
        "files_with_matches",
        "count"
      ],
      "nullable": true
    },
    "path": {
      "description": "File or directory to search in (rg PATH). Defaults to current working directory.",
      "type": "string",
      "nullable": true
    },
    "pattern": {
      "description": "The regular expression pattern to search for in file contents.",
      "type": "string"
    },
    "type": {
      "description": "File type to search (rg --type). Common types: js, py, rust, go, java, etc. More efficient than include for standard file types.",
      "type": "string",
      "nullable": true
    }
  }
}
{
  "title": "SemanticSearch",
  "type": "object",
  "required": [
    "queries"
  ],
  "properties": {
    "queries": {
      "description": "List of search queries to execute in parallel. Using multiple queries (2-3) with varied phrasings significantly improves results - each query captures different aspects of what you're looking for. Each query pairs a search term with a use_case for reranking. Example: for authentication, try \"user login verification\", \"token generation\", \"OAuth flow\".",
      "type": "array",
      "items": {
        "description": "A paired query and use_case for semantic search. Each query must have a corresponding use_case for document reranking.",
        "type": "object",
        "required": [
          "query",
          "use_case"
        ],
        "properties": {
          "query": {
            "description": "Describe WHAT the code does or its purpose. Include domain-specific terms and technical context. Good: \"retry mechanism with exponential backoff\", \"streaming responses from LLM API\", \"OAuth token refresh flow\". Bad: generic terms like \"retry\" or \"auth\" without context. Think about the behavior and functionality you're looking for.",
            "type": "string"
          },
          "use_case": {
            "description": "A short natural-language description of what you are trying to find. This is the query used for document reranking. The query MUST: - express a single, focused information need - describe exactly what the agent is searching for - should not be the query verbatim - be concise (1â€“2 sentences)\n\nExamples: - \"Why is `select_model()` returning a Pin<Box<Result>> in Rust?\" - \"How to fix error E0277 for the ? operator on a pinned boxed result?\" - \"Steps to run Diesel migrations in Rust without exposing the DB.\" - \"How to design a clean architecture service layer with typed errors?\"",
            "type": "string"
          }
        }
      }
    }
  }
}
{
  "title": "FSRemove",
  "type": "object",
  "required": [
    "path"
  ],
  "properties": {
    "path": {
      "description": "The path of the file to remove (absolute path required)",
      "type": "string"
    }
  }
}
{
  "title": "FSPatch",
  "type": "object",
  "required": [
    "file_path",
    "new_string",
    "old_string"
  ],
  "properties": {
    "file_path": {
      "description": "The absolute path to the file to modify",
      "type": "string"
    },
    "new_string": {
      "description": "The text to replace it with (must be different from old_string)",
      "type": "string"
    },
    "old_string": {
      "description": "The text to replace",
      "type": "string"
    },
    "replace_all": {
      "description": "Replace all occurrences of old_string (default false)",
      "default": false,
      "type": "boolean"
    }
  }
}
{
  "title": "FSUndo",
  "type": "object",
  "required": [
    "path"
  ],
  "properties": {
    "path": {
      "description": "The absolute path of the file to revert to its previous state.",
      "type": "string"
    }
  }
}
{
  "title": "Shell",
  "type": "object",
  "required": [
    "command"
  ],
  "properties": {
    "command": {
      "description": "The shell command to execute.",
      "type": "string"
    },
    "cwd": {
      "description": "The working directory where the command should be executed. If not specified, defaults to the current working directory from the environment.",
      "type": "string",
      "nullable": true
    },
    "description": {
      "description": "Clear, concise description of what this command does. Recommended to be 5-10 words for simple commands. For complex commands with pipes or multiple operations, provide more context. Examples: \"Lists files in current directory\", \"Installs package dependencies\", \"Compiles Rust project with release optimizations\".",
      "type": "string",
      "nullable": true
    },
    "env": {
      "description": "Environment variable names to pass to command execution (e.g., [\"PATH\", \"HOME\", \"USER\"]). The system automatically reads the specified values and applies them during command execution.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "nullable": true
    },
    "keep_ansi": {
      "description": "Whether to preserve ANSI escape codes in the output. If true, ANSI escape codes will be preserved in the output. If false (default), ANSI escape codes will be stripped from the output.",
      "type": "boolean"
    }
  }
}
{
  "title": "NetFetch",
  "description": "Input type for the net fetch tool",
  "type": "object",
  "required": [
    "url"
  ],
  "properties": {
    "raw": {
      "description": "Get raw content without any markdown conversion (default: false)",
      "type": "boolean",
      "nullable": true
    },
    "url": {
      "description": "URL to fetch",
      "type": "string"
    }
  }
}
{
  "title": "Followup",
  "type": "object",
  "required": [
    "question"
  ],
  "properties": {
    "multiple": {
      "description": "If true, allows selecting multiple options; if false (default), only one option can be selected",
      "type": "boolean",
      "nullable": true
    },
    "option1": {
      "description": "First option to choose from",
      "type": "string",
      "nullable": true
    },
    "option2": {
      "description": "Second option to choose from",
      "type": "string",
      "nullable": true
    },
    "option3": {
      "description": "Third option to choose from",
      "type": "string",
      "nullable": true
    },
    "option4": {
      "description": "Fourth option to choose from",
      "type": "string",
      "nullable": true
    },
    "option5": {
      "description": "Fifth option to choose from",
      "type": "string",
      "nullable": true
    },
    "question": {
      "description": "Question to ask the user",
      "type": "string"
    }
  }
}
{
  "title": "PlanCreate",
  "type": "object",
  "required": [
    "content",
    "plan_name",
    "version"
  ],
  "properties": {
    "content": {
      "description": "The content to write to the plan file. This should be the complete plan content in markdown format.",
      "type": "string"
    },
    "plan_name": {
      "description": "The name of the plan (will be used in the filename)",
      "type": "string"
    },
    "version": {
      "description": "The version of the plan (e.g., \"v1\", \"v2\", \"1.0\")",
      "type": "string"
    }
  }
}
{
  "title": "SkillFetch",
  "type": "object",
  "required": [
    "name"
  ],
  "properties": {
    "name": {
      "description": "The name of the skill to fetch (e.g., \"pdf\", \"code_review\")",
      "type": "string"
    }
  }
}
