---
source: crates/forge_domain/src/tools/catalog.rs
expression: tools
---
{
  "title": "FSRead",
  "type": "object",
  "required": [
    "path"
  ],
  "properties": {
    "end_line": {
      "description": "Optional end position in lines (inclusive). If provided, reading will end at this line position.",
      "type": "integer",
      "format": "int32",
      "nullable": true
    },
    "path": {
      "description": "The path of the file to read, always provide absolute paths.",
      "type": "string"
    },
    "show_line_numbers": {
      "description": "If true, prefixes each line with its line index (starting at 1). Defaults to true.",
      "default": true,
      "type": "boolean"
    },
    "start_line": {
      "description": "Optional start position in lines (1-based). If provided, reading will start from this line position.",
      "type": "integer",
      "format": "int32",
      "nullable": true
    }
  }
}
{
  "title": "ReadImage",
  "type": "object",
  "required": [
    "path"
  ],
  "properties": {
    "path": {
      "description": "The absolute path to the image file (e.g., /home/user/image.png). Relative paths are not supported. The file must exist and be readable.",
      "type": "string"
    }
  }
}
{
  "title": "FSWrite",
  "type": "object",
  "required": [
    "content",
    "path"
  ],
  "properties": {
    "content": {
      "description": "The content to write to the file. ALWAYS provide the COMPLETE intended content of the file, without any truncation or omissions. You MUST include ALL parts of the file, even if they haven't been modified.",
      "type": "string"
    },
    "overwrite": {
      "description": "If set to true, existing files will be overwritten. If not set and the file exists, an error will be returned with the content of the existing file.",
      "type": "boolean"
    },
    "path": {
      "description": "The path of the file to write to (absolute path required)",
      "type": "string"
    }
  }
}
{
  "title": "FSSearch",
  "type": "object",
  "required": [
    "path"
  ],
  "properties": {
    "file_pattern": {
      "description": "Glob pattern to filter files (e.g., '*.ts' for TypeScript files). If not provided, it will search all files (*).",
      "type": "string",
      "nullable": true
    },
    "max_search_lines": {
      "description": "Maximum number of lines to return in the search results.",
      "type": "integer",
      "format": "int32",
      "nullable": true
    },
    "path": {
      "description": "The absolute path of the directory or file to search in. If it's a directory, it will be searched recursively. If it's a file path, only that specific file will be searched.",
      "type": "string"
    },
    "regex": {
      "description": "The regular expression pattern to search for in file contents. Uses Rust regex syntax. If not provided, only file name matching will be performed.",
      "type": "string",
      "nullable": true
    },
    "start_index": {
      "description": "Starting index for the search results (1-based).",
      "type": "integer",
      "format": "int32",
      "nullable": true
    }
  }
}
{
  "title": "SemanticSearch",
  "type": "object",
  "required": [
    "queries"
  ],
  "properties": {
    "file_extension": {
      "description": "Optional file extension filter (e.g., \".rs\", \".ts\", \".py\"). If provided, only files with this extension will be included in the search results.",
      "type": "string",
      "nullable": true
    },
    "queries": {
      "description": "List of search queries to execute in parallel. Using multiple queries (2-3) with varied phrasings significantly improves results - each query captures different aspects of what you're looking for. Each query pairs a search term with a use_case for reranking. Example: for authentication, try \"user login verification\", \"token generation\", \"OAuth flow\".",
      "type": "array",
      "items": {
        "description": "A paired query and use_case for semantic search. Each query must have a corresponding use_case for document reranking.",
        "type": "object",
        "required": [
          "query",
          "use_case"
        ],
        "properties": {
          "query": {
            "description": "Describe WHAT the code does or its purpose. Include domain-specific terms and technical context. Good: \"retry mechanism with exponential backoff\", \"streaming responses from LLM API\", \"OAuth token refresh flow\". Bad: generic terms like \"retry\" or \"auth\" without context. Think about the behavior and functionality you're looking for.",
            "type": "string"
          },
          "use_case": {
            "description": "A short natural-language description of what you are trying to find. This is the query used for document reranking. The query MUST: - express a single, focused information need - describe exactly what the agent is searching for - should not be the query verbatim - be concise (1â€“2 sentences)\n\nExamples: - \"Why is `select_model()` returning a Pin<Box<Result>> in Rust?\" - \"How to fix error E0277 for the ? operator on a pinned boxed result?\" - \"Steps to run Diesel migrations in Rust without exposing the DB.\" - \"How to design a clean architecture service layer with typed errors?\"",
            "type": "string"
          }
        }
      }
    }
  }
}
{
  "title": "FSRemove",
  "type": "object",
  "required": [
    "path"
  ],
  "properties": {
    "path": {
      "description": "The path of the file to remove (absolute path required)",
      "type": "string"
    }
  }
}
{
  "title": "FSPatch",
  "type": "object",
  "required": [
    "content",
    "operation",
    "path"
  ],
  "properties": {
    "content": {
      "description": "The text to replace it with (must be different from search)",
      "type": "string"
    },
    "operation": {
      "description": "The operation to perform on the matched text. Possible options are: - 'prepend': Add content before the matched text - 'append': Add content after the matched text - 'replace': Use only for specific, targeted replacements where you need to modify just the first match. - 'replace_all': Should be used for renaming variables, functions, types, or any widespread replacements across the file. This is the recommended choice for consistent refactoring operations as it ensures all occurrences are updated. - 'swap': Replace the matched text with another text (search for the second text and swap them)",
      "type": "string",
      "enum": [
        "prepend",
        "append",
        "replace",
        "replace_all",
        "swap"
      ]
    },
    "path": {
      "description": "The path to the file to modify",
      "type": "string"
    },
    "search": {
      "description": "The text to replace. When skipped the patch operation applies to the entire content. `Append` adds the new content to the end, `Prepend` adds it to the beginning, and `Replace` fully overwrites the original content. `Swap` requires a search target, so without one, it makes no changes.",
      "type": "string",
      "nullable": true
    }
  }
}
{
  "title": "FSUndo",
  "type": "object",
  "required": [
    "path"
  ],
  "properties": {
    "path": {
      "description": "The absolute path of the file to revert to its previous state.",
      "type": "string"
    }
  }
}
{
  "title": "Shell",
  "type": "object",
  "required": [
    "command",
    "cwd"
  ],
  "properties": {
    "command": {
      "description": "The shell command to execute.",
      "type": "string"
    },
    "cwd": {
      "description": "The working directory where the command should be executed.",
      "type": "string"
    },
    "env": {
      "description": "Environment variable names to pass to command execution (e.g., [\"PATH\", \"HOME\", \"USER\"]). The system automatically reads the specified values and applies them during command execution.",
      "type": "array",
      "items": {
        "type": "string"
      },
      "nullable": true
    },
    "keep_ansi": {
      "description": "Whether to preserve ANSI escape codes in the output. If true, ANSI escape codes will be preserved in the output. If false (default), ANSI escape codes will be stripped from the output.",
      "type": "boolean"
    }
  }
}
{
  "title": "NetFetch",
  "description": "Input type for the net fetch tool",
  "type": "object",
  "required": [
    "url"
  ],
  "properties": {
    "raw": {
      "description": "Get raw content without any markdown conversion (default: false)",
      "type": "boolean",
      "nullable": true
    },
    "url": {
      "description": "URL to fetch",
      "type": "string"
    }
  }
}
{
  "title": "Followup",
  "type": "object",
  "required": [
    "question"
  ],
  "properties": {
    "multiple": {
      "description": "If true, allows selecting multiple options; if false (default), only one option can be selected",
      "type": "boolean",
      "nullable": true
    },
    "option1": {
      "description": "First option to choose from",
      "type": "string",
      "nullable": true
    },
    "option2": {
      "description": "Second option to choose from",
      "type": "string",
      "nullable": true
    },
    "option3": {
      "description": "Third option to choose from",
      "type": "string",
      "nullable": true
    },
    "option4": {
      "description": "Fourth option to choose from",
      "type": "string",
      "nullable": true
    },
    "option5": {
      "description": "Fifth option to choose from",
      "type": "string",
      "nullable": true
    },
    "question": {
      "description": "Question to ask the user",
      "type": "string"
    }
  }
}
{
  "title": "PlanCreate",
  "type": "object",
  "required": [
    "content",
    "plan_name",
    "version"
  ],
  "properties": {
    "content": {
      "description": "The content to write to the plan file. This should be the complete plan content in markdown format.",
      "type": "string"
    },
    "plan_name": {
      "description": "The name of the plan (will be used in the filename)",
      "type": "string"
    },
    "version": {
      "description": "The version of the plan (e.g., \"v1\", \"v2\", \"1.0\")",
      "type": "string"
    }
  }
}
{
  "title": "SkillFetch",
  "type": "object",
  "required": [
    "name"
  ],
  "properties": {
    "name": {
      "description": "The name of the skill to fetch (e.g., \"pdf\", \"code_review\")",
      "type": "string"
    }
  }
}
